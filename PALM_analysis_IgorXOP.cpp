/*
 *  PALM_analysis_IgorXOP.cpp
 *  PALM analysis
 *
 *  Created by Peter Dedecker on 05/01/2008.
 *  Copyright 2008 __MyCompanyName__. All rights reserved.
 *
 */

#include "PALM_analysis_IgorXOP.h"

// the framework below was generated by Igor

// Runtime param structure for AnalyzePALMImages operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct AnalyzePALMImagesRuntimeParams {
	// Flag parameters.
	
	// Parameters for /M flag group.
	int MFlagEncountered;
	double method;
	int MFlagParamsSet[1];
	
	// Parameters for /D flag group.
	int DFlagEncountered;
	double thresholding_method;
	int DFlagParamsSet[1];
	
	// Parameters for /Y flag group.
	int YFlagEncountered;
	double camera_type;
	int YFlagParamsSet[1];
	
	// Parameters for /G flag group.
	int GFlagEncountered;
	double preprocessing;
	double postprocessing;
	int GFlagParamsSet[2];
	
	// Parameters for /F flag group.
	int FFlagEncountered;
	double particle_finder;
	int FFlagParamsSet[1];
	
	// Parameters for /PVER flag group.
	int PVERFlagEncountered;
	double particleVerifiers[100];			// Optional parameter.
	int PVERFlagParamsSet[100];
	
	// Parameters for /T flag group.
	int TFlagEncountered;
	double treshold_parameter;
	int TFlagParamsSet[1];
	
	// Parameters for /PFA flag group.
	int PFAFlagEncountered;
	double PFA;
	int PFAFlagParamsSet[1];
	
	// Parameters for /R flag group.
	int RFlagEncountered;
	double radius;
	int RFlagParamsSet[1];
	
	// Parameters for /W flag group.
	int WFlagEncountered;
	double initial_width;
	int WFlagParamsSet[1];
	
	// Parameters for /S flag group.
	int SFlagEncountered;
	double sigma;
	int SFlagParamsSet[1];
	
	// Parameters for /P flag group.
	int PFlagEncountered;
	waveHndl positions_wave;
	int PFlagParamsSet[1];
	
	// Parameters for /Q flag group.
	int QFlagEncountered;
	// There are no fields for this group because it has no parameters.
	
	// Parameters for /Z flag group.
	int ZFlagEncountered;
	// There are no fields for this group because it has no parameters.
	
	// Main parameters.
	
	// Parameters for simple main group #0.
	int outputWaveParamsEncountered;
	DataFolderAndName outputWaveParams;
	int outputWaveParamsParamsSet[1];
	
	// Parameters for simple main group #1.
	int experiment_fileEncountered;
	Handle experiment_file;
	int experiment_fileParamsSet[1];
	
	// These are postamble fields that Igor sets.
	int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
	int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
};
typedef struct AnalyzePALMImagesRuntimeParams AnalyzePALMImagesRuntimeParams;
typedef struct AnalyzePALMImagesRuntimeParams* AnalyzePALMImagesRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.

// Runtime param structure for ReadCCDImages operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct ReadCCDImagesRuntimeParams {
	// Flag parameters.
	
	// Parameters for /Y flag group.
	int YFlagEncountered;
	double camera_type;
	int YFlagParamsSet[1];
	
	// Parameters for /H flag group.
	int HFlagEncountered;
	// There are no fields for this group because it has no parameters.
	
	// Parameters for /Z flag group.
	int ZFlagEncountered;
	// There are no fields for this group because it has no parameters.
	
	// Main parameters.
	
	// Parameters for simple main group #0.
	int start_imageEncountered;
	double start_image;
	int start_imageParamsSet[1];
	
	// Parameters for simple main group #1.
	int end_imageEncountered;
	double end_image;
	int end_imageParamsSet[1];
	
	// Parameters for simple main group #2.
	int experiment_fileEncountered;
	Handle experiment_file;
	int experiment_fileParamsSet[1];
	
	// These are postamble fields that Igor sets.
	int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
	int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
	struct tag_UserFuncThreadInfo *tp;		// If not null, we are running from a ThreadSafe function.
};
typedef struct ReadCCDImagesRuntimeParams ReadCCDImagesRuntimeParams;
typedef struct ReadCCDImagesRuntimeParams* ReadCCDImagesRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.

// Runtime param structure for ProcessCCDImages operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct ProcessCCDImagesRuntimeParams {
	// Flag parameters.
	
	// Parameters for /Y flag group.
	int YFlagEncountered;
	double camera_type;
	int YFlagParamsSet[1];
	
	// Parameters for /M flag group.
	int MFlagEncountered;
	double method;
	int MFlagParamsSet[1];
	
	// Parameters for /N flag group.
	int NFlagEncountered;
	double method_parameter;
	int NFlagParamsSet[1];
	
	// Parameters for /R flag group.
	int RFlagEncountered;
	double startX;
	double endX;
	double startY;
	double endY;
	int RFlagParamsSet[4];
	
	// Parameters for /OUT flag group.
	int OUTFlagEncountered;
	double outputType;
	int OUTFlagParamsSet[1];
	
	// Parameters for /O flag group.
	int OFlagEncountered;
	// There are no fields for this group because it has no parameters.
	
	// Main parameters.
	
	// Parameters for simple main group #0.
	int input_fileEncountered;
	Handle input_file;
	int input_fileParamsSet[1];
	
	// Parameters for simple main group #1.
	int output_fileEncountered;
	Handle output_file;
	int output_fileParamsSet[1];
	
	// These are postamble fields that Igor sets.
	int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
	int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
};
typedef struct ProcessCCDImagesRuntimeParams ProcessCCDImagesRuntimeParams;
typedef struct ProcessCCDImagesRuntimeParams* ProcessCCDImagesRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.

// Runtime param structure for AnalyzeCCDImages operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct AnalyzeCCDImagesRuntimeParams {
	// Flag parameters.
	
	// Parameters for /Y flag group.
	int YFlagEncountered;
	double camera_type;
	int YFlagParamsSet[1];
	
	// Parameters for /M flag group.
	int MFlagEncountered;
	double method;
	int MFlagParamsSet[1];
	
	// Parameters for /R flag group.
	int RFlagEncountered;
	double startX;
	double endX;
	double startY;
	double endY;
	int RFlagParamsSet[4];
	
	// Main parameters.
	
	// Parameters for simple main group #0.
	int outputWaveParamsEncountered;
	DataFolderAndName outputWaveParams;
	int outputWaveParamsParamsSet[1];
	
	// Parameters for simple main group #1.
	int input_fileEncountered;
	Handle input_file;
	int input_fileParamsSet[1];
	
	// These are postamble fields that Igor sets.
	int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
	int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
};
typedef struct AnalyzeCCDImagesRuntimeParams AnalyzeCCDImagesRuntimeParams;
typedef struct AnalyzeCCDImagesRuntimeParams* AnalyzeCCDImagesRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.

// Runtime param structure for TestThreshold operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct TestThresholdRuntimeParams {
	// Flag parameters.
	
	// Parameters for /M flag group.
	int MFlagEncountered;
	double method;
	int MFlagParamsSet[1];
	
	// Parameters for /ABS flag group.
	int ABSFlagEncountered;
	double absoluteThreshold;
	int ABSFlagParamsSet[1];
	
	// Parameters for /PFA flag group.
	int PFAFlagEncountered;
	double PFA;
	int PFAFlagParamsSet[1];
	
	// Parameters for /WDTH flag group.
	int WDTHFlagEncountered;
	double PSFWidth;
	int WDTHFlagParamsSet[1];
	
	// Parameters for /G flag group.
	int GFlagEncountered;
	double preprocessing;
	double postprocessing;
	int GFlagParamsSet[2];
	
	// Parameters for /F flag group.
	int FFlagEncountered;
	double particle_finder;
	int FFlagParamsSet[1];
	
	// Parameters for /PVER flag group.
	int PVERFlagEncountered;
	double particleVerifiers[100];			// Optional parameter.
	int PVERFlagParamsSet[100];
	
	// Parameters for /R flag group.
	int RFlagEncountered;
	double radiusBetweenParticles;
	int RFlagParamsSet[1];
	
	// Parameters for /S flag group.
	int SFlagEncountered;
	double output_located_particles;
	int SFlagParamsSet[1];
	
	// Main parameters.
	
	// Parameters for simple main group #0.
	int CCD_FrameEncountered;
	waveHndl CCD_Frame;
	int CCD_FrameParamsSet[1];
	
	// These are postamble fields that Igor sets.
	int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
	int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
};
typedef struct TestThresholdRuntimeParams TestThresholdRuntimeParams;
typedef struct TestThresholdRuntimeParams* TestThresholdRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.

// Runtime param structure for ConvolveImages operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct ConvolveImagesRuntimeParams {
	// Flag parameters.
	
	// Main parameters.
	
	// Parameters for simple main group #0.
	int firstImageEncountered;
	waveHndl firstImage;
	int firstImageParamsSet[1];
	
	// Parameters for simple main group #1.
	int secondImageEncountered;
	waveHndl secondImage;
	int secondImageParamsSet[1];
	
	// These are postamble fields that Igor sets.
	int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
	int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
};
typedef struct ConvolveImagesRuntimeParams ConvolveImagesRuntimeParams;
typedef struct ConvolveImagesRuntimeParams* ConvolveImagesRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.


// Runtime param structure for MakeBitmapPALMImage operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct MakeBitmapPALMImageRuntimeParams {
	// Flag parameters.
	
	// Parameters for /M flag group.
	int MFlagEncountered;
	double deviationMethod;
	int MFlagParamsSet[1];
	
	// Parameters for /S flag group.
	int SFlagEncountered;
	double scaleFactor;
	int SFlagParamsSet[1];
	
	// Parameters for /L flag group.
	int LFlagEncountered;
	double upperLimit;
	int LFlagParamsSet[1];
	
	// Parameters for /W flag group.
	int WFlagEncountered;
	double CCDXSize;
	double CCDYSize;
	double ImageWidth;
	double ImageHeight;
	int WFlagParamsSet[4];
	
	// Parameters for /WGHT flag group.
	int WGHTFlagEncountered;
	double emitterWeighing;
	int WGHTFlagParamsSet[1];
	
	// Parameters for /P flag group.
	int PFlagEncountered;
	double PSFWidth;
	int PFlagParamsSet[1];
	
	// Main parameters.
	
	// Parameters for simple main group #0.
	int positionsWaveEncountered;
	waveHndl positionsWave;
	int positionsWaveParamsSet[1];
	
	// These are postamble fields that Igor sets.
	int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
	int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
};
typedef struct MakeBitmapPALMImageRuntimeParams MakeBitmapPALMImageRuntimeParams;
typedef struct MakeBitmapPALMImageRuntimeParams* MakeBitmapPALMImageRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.

// Runtime param structure for RipleyLFunctionClustering operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct RipleyLFunctionClusteringRuntimeParams {
	// Flag parameters.
	
	// Parameters for /RNGE flag group.
	int RNGEFlagEncountered;
	double calculationRange;
	double nBins;
	int RNGEFlagParamsSet[2];
	
	// Parameters for /REGN flag group.
	int REGNFlagEncountered;
	double lowerX;
	double upperX;
	double lowerY;
	double upperY;
	int REGNFlagParamsSet[4];
	
	// Main parameters.
	
	// Parameters for simple main group #0.
	int positionsWaveEncountered;
	waveHndl positionsWave;
	int positionsWaveParamsSet[1];
	
	// These are postamble fields that Igor sets.
	int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
	int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
};
typedef struct RipleyLFunctionClusteringRuntimeParams RipleyLFunctionClusteringRuntimeParams;
typedef struct RipleyLFunctionClusteringRuntimeParams* RipleyLFunctionClusteringRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.


static int ExecuteAnalyzePALMImages(AnalyzePALMImagesRuntimeParamsPtr p) {
	gsl_set_error_handler_off();	// we will handle errors ourselves
	int err = 0;
	double directThreshold, PFA, radiusBetweenParticles, initial_width, sigma;
	DataFolderAndName outputWaveParams;
	std::string data_file_path;
	size_t camera_type;
	int method;
	int particle_finding_method;
	int fitting_positions_supplied_in_wave = 0;	// determines if we have to determine the positions to fit in ourselves, or if we can read them from the wave
	long numDimensions;
	long dimensionSizes[MAX_DIMENSIONS + 1];
	waveHndl fitting_positions = NULL;
	int quiet = 0;
	int returnErrors = 1;
	
	std::ostringstream analysisOptionsStream;	// a stringstream that is built up during the options parsing
												// and contains the settings that are used
												// it can be used to add metadata to the fitted positions
												// such as wave notes or file headers
												// the information is added in semicolon-separated key:value pairs
	
	size_t preprocessing_method;
	size_t thresholding_method;
	size_t postprocessing_method;
	std::vector<size_t> particleVerifierMethods;
	
	boost::shared_ptr<ImageLoader> image_loader;
	boost::shared_ptr<FitPositions> positions_fitter;
	boost::shared_ptr<ThresholdImage> thresholder;
	boost::shared_ptr<ThresholdImage_Preprocessor> preprocessor;
	boost::shared_ptr<ThresholdImage_Postprocessor> postprocessor;
	boost::shared_ptr<ParticleFinder> particle_finder;
	std::vector<boost::shared_ptr<ParticleVerifier> > particleVerifiers;
	boost::shared_ptr<PALMAnalysisController> analysisController;
	boost::shared_ptr<LocalizedPositionsContainer> localizedPositions;
	boost::shared_ptr<PALMAnalysisProgressReporter> progressReporter;
	
	// Flag parameters.
	
	if (p->MFlagEncountered) {
		// Parameter: p->method
		
		// 0 means Gaussian fitting
		// 1 means multiplication method (Thompson, Biophys J 2002)
		method = (int)(p->method + 0.5);
		analysisOptionsStream << "LOCALIZATION METHOD:" << method << ';';
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->DFlagEncountered) {
		// Parameter: p->thresholding_method
		thresholding_method = (int)(p->thresholding_method + 0.5);
		analysisOptionsStream << "THRESHOLD METHOD:" << thresholding_method << ';';
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->YFlagEncountered) {
		// Parameter: p->camera_type
		camera_type = (size_t)(p->camera_type + 0.5);
		analysisOptionsStream << "THRESHOLD METHOD:" << camera_type << ';';
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->GFlagEncountered) {
		// Parameter: p->preprocessing
		// Parameter: p->postprocessing
		preprocessing_method = (size_t)(p->preprocessing + 0.5);
		postprocessing_method = (size_t)(p->postprocessing + 0.5);
	} else {
		// if this flag doesn't appear then we assume that we don't want any pre- or postprocessing
		preprocessing_method = 0;
		postprocessing_method = 0;
	}
	
	analysisOptionsStream << "PREPROCESSING:" << preprocessing_method << ';';
	analysisOptionsStream << "POSTPROCESSING:" << postprocessing_method << ';';
	
	if (p->FFlagEncountered) {
		// Parameter: p->particle_finder
		particle_finding_method = (int)(p->particle_finder + 0.5);
		analysisOptionsStream << "PARTICLE FINDING METHOD:" << particle_finding_method << ';';
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->PVERFlagEncountered) {
		int* paramsSet = &p->PVERFlagParamsSet[0];
		size_t particleVerifierMethod;
		
		for (int i=0; i<100; i++) {
			if (paramsSet[i] == 0)
				break;		// No more parameters.
			
			particleVerifierMethod = (size_t)(p->particleVerifiers[i] + 0.5);
			
			if ((particleVerifierMethod == PARTICLEVERIFIER_SYMMETRICGAUSS) && (method == LOCALIZATION_METHOD_2DGAUSS)) {
				// there's no need to fit the same positions with the same algorithm twice, drop this verification
				continue;
			} else if ((particleVerifierMethod == PARTICLEVERIFIER_ELLIPSOIDALGAUSS) && (method == LOCALIZATION_METHOD_2DGAUSS_ELLIPSOIDAL)) {
				continue;
			}
			
			particleVerifierMethods.push_back(particleVerifierMethod);
		}
	} else {
		particleVerifierMethods.push_back(PARTICLEVERIFIER_NONE);
	}
	
	if (p->TFlagEncountered) {
		// Parameter: p->treshold_parameter
		directThreshold = p->treshold_parameter;
		if (thresholding_method == THRESHOLD_METHOD_DIRECT)
			analysisOptionsStream << "ABSOLUTE THRESHOLD:" << directThreshold << ';';	
	} else if (thresholding_method == THRESHOLD_METHOD_DIRECT)
			return TOO_FEW_PARAMETERS;
	
	if (p->PFAFlagEncountered) {
		// Parameter: p->PFA
		PFA = p->PFA;
		if (thresholding_method == THRESHOLD_METHOD_GLRT)
			analysisOptionsStream << "PFA:" << PFA << ';';
	} else if (thresholding_method == THRESHOLD_METHOD_GLRT)
		return TOO_FEW_PARAMETERS;
	
	
	if (p->RFlagEncountered) {
		// Parameter: p->radius
		radiusBetweenParticles = p->radius;
		if (particle_finding_method == PARTICLEFINDER_RADIUS) {
			analysisOptionsStream << "MINIMUM DISTANCE BETWEEN PARTICLES:" << particle_finding_method << ';';
		}
	} else {
		if (particle_finding_method == PARTICLEFINDER_RADIUS) {
			return TOO_FEW_PARAMETERS;
		}
	}
	
	if (p->WFlagEncountered) {
		// Parameter: p->initial_width
		initial_width = p->initial_width;
	} else {
		initial_width = 2;
	}
	
	if (method != LOCALIZATION_METHOD_CENTROID)
		analysisOptionsStream << "PSF WIDTH:" << initial_width << ';';
	
	if (p->SFlagEncountered) {
		// Parameter: p->sigma
		sigma = p->sigma;
	} else {
		sigma = 1;
	}
	
	if (p->PFlagEncountered) {
		// Parameter: p->positions_wave (test for NULL handle before using)
		if (p->positions_wave == NULL) {
			return NOWAV;
		}
		
		fitting_positions = p->positions_wave;
		
		if (WaveType(fitting_positions) != NT_FP64) {
			return NT_INCOMPATIBLE;
		}
		
		err = MDGetWaveDimensions(fitting_positions, &numDimensions, dimensionSizes);
		if (err != 0) {
			return err;
		}
		
		if ((numDimensions != 2) || (dimensionSizes[1] != 3)) {
			return INCOMPATIBLE_DIMENSIONING;
		}
		
		fitting_positions_supplied_in_wave = 1;
	} else {
		fitting_positions_supplied_in_wave = 0;
	}
	
	if (p->QFlagEncountered) {
		quiet = 1;
	} else {
		quiet = 0;
	}
	
	if (p->ZFlagEncountered) {
		returnErrors = 0;
	} else {
		returnErrors = 1;
	}
	
	// Main parameters.
	
	if (p->outputWaveParamsEncountered) {
		// Parameter: p->outputWaveParams
		outputWaveParams = p->outputWaveParams;
	} else {
		return EXPECTED_NAME;
	}
	
	try {
		
		if (p->experiment_fileEncountered) {
			// Parameter: p->experiment_file (test for NULL handle before using)
			if (p->experiment_file == NULL) {
				return EXPECTED_STRING_EXPR;
			}
			
			if (camera_type != CAMERA_TYPE_IGOR_WAVE) {
				err = ConvertHandleToFilepathString(p->experiment_file, data_file_path);
				if (err != 0) {
					return err;
				}
			} else {	// if we are loading data from an Igor wave then there is no need to convert
				err = ConvertHandleToString(p->experiment_file, data_file_path);
				if (err != 0) {
					return err;
				}
			}
			
			image_loader = get_image_loader_for_camera_type(camera_type, data_file_path);
			
			analysisOptionsStream << "ORIGINAL FILE PATH:" << data_file_path << ';';
			analysisOptionsStream << "CAMERA TYPE:" << camera_type << ';';
			analysisOptionsStream << "X SIZE:" << image_loader->getXSize() << ';';
			analysisOptionsStream << "Y SIZE:" << image_loader->getYSize() << ';';
			
		} else {	// file path parameter was not supplied from igor
			return EXPECTED_STRING_EXPR;
		}
		
		// which preprocessing do we wish to do?
		switch(preprocessing_method) {
			case PREPROCESSOR_NONE:	// no preprocessing
				//preprocessor = NULL;	// this is the default for a shared_ptr
				break;
			case PREPROCESSOR_3X3MEDIAN:	// 3x3 median filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MedianFilter(3,3));
				break;
			case PREPROCESSOR_5X5MEDIAN:	// 5x5 median filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MedianFilter(5,5));
				break;
			case PREPROCESSOR_1X1GAUSSIAN:	// 1x1 Gaussian filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_GaussianSmoothing(1));
				break;
			case PREPROCESSOR_2X2GAUSSIAN:	// 2x2 Gaussian filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_GaussianSmoothing(2));
				break;
			case PREPROCESSOR_3X3MEAN:	// 3x3 mean filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MeanFilter(3,3));
				break;
			case PREPROCESSOR_5X5MEAN:	// 5x5 mean filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MeanFilter(5,5));
				break;
			default:
				throw std::runtime_error("Unknown segmentation preprocessing method");
				break;
		}
		
		
		// choose which thresholding we want to do
		switch(thresholding_method) {
			case THRESHOLD_METHOD_GLRT:	// the GLRT test proposed by Arnauld et al in Nat Methods 5:687 2008
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_GLRT_FFT(PFA, initial_width));
				break;
			case THRESHOLD_METHOD_IGOR_ITERATIVE:	// Igor's iterative approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Iterative());
				break;
			case THRESHOLD_METHOD_IGOR_BIMODAL:	// Igor's iterative approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Bimodal());
				break;
			case THRESHOLD_METHOD_IGOR_ADAPTIVE:	// Igor's adaptive approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Adaptive());
				break;
			case THRESHOLD_METHOD_IGOR_FUZZY_1:	// Igor's first fuzzy approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Fuzzy1());
				break;
			case THRESHOLD_METHOD_IGOR_FUZZY_2:	// Igor's second fuzzy approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Fuzzy2());
				break;
			case THRESHOLD_METHOD_ISODATA:	// isodata algorithm (http://www.ph.tn.tudelft.nl/Courses/FIP/noframes/fip-Segmenta.html)
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Isodata());
				break;
			case THRESHOLD_METHOD_TRIANGLE:	// modified triangle algorithm (http://www.ph.tn.tudelft.nl/Courses/FIP/noframes/fip-Segmenta.html)
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Triangle());
				break;
			case THRESHOLD_METHOD_DIRECT:	// direct threshold
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Direct(directThreshold));
				break;
			default:
				throw std::runtime_error("Unknown segmentation method");
				break;
		}
		
		// which postprocessing do we wish to do?
		switch(postprocessing_method) {
			case POSTPROCESSOR_NONE:	// no postprocessing
				//postprocessor = NULL;	// this is the default for a shared_ptr
				break;
			case POSTPROCESSOR_REMOVE_ISOLATED_PIXELS:	// remove isolated pixels
				postprocessor = boost::shared_ptr<ThresholdImage_Postprocessor>(new ThresholdImage_Postprocessor_RemoveIsolatedPixels());
				break;
			default:
				throw std::runtime_error("Unknown segmentation postprocessing method");
				break;
		}
		
		// which particle finding method do we wish to use?
		switch (particle_finding_method) {
			case PARTICLEFINDER_ADJACENT4:
				particle_finder = boost::shared_ptr<ParticleFinder>(new ParticleFinder_adjacent4());
				break;
			case PARTICLEFINDER_ADJACENT8:
				particle_finder = boost::shared_ptr<ParticleFinder>(new ParticleFinder_adjacent8());
				break;
			case PARTICLEFINDER_RADIUS:	// traditional radius approach
				particle_finder = boost::shared_ptr<ParticleFinder>(new ParticleFinder_radius(radiusBetweenParticles));
				break;
			default:
				throw std::runtime_error("Unknown particle finding method");
				break;
		}
		
		// what particle verification do we wish to use?
		// several particle verifiers can be used
		for (std::vector<size_t>::iterator it = particleVerifierMethods.begin(); it != particleVerifierMethods.end(); ++it) {
			switch (*it) {
				case PARTICLEVERIFIER_NONE:
					// no particle verification requested for this entry, do nothing
					break;
				case PARTICLEVERIFIER_SYMMETRICGAUSS:
					particleVerifiers.push_back(boost::shared_ptr<ParticleVerifier> (new ParticleVerifier_SymmetricGaussian(initial_width, sigma)));
					break;
				case PARTICLEVERIFIER_ELLIPSOIDALGAUSS:
					particleVerifiers.push_back(boost::shared_ptr<ParticleVerifier> (new ParticleVerifier_EllipsoidalGaussian(initial_width, sigma)));
					break;
				case PARTICLEVERIFIER_REMOVEOVERLAPPINGPARTICLES:
					particleVerifiers.push_back(boost::shared_ptr<ParticleVerifier> (new ParticleVerifier_RemoveOverlappingParticles(initial_width)));
					break;
				default:
					throw std::runtime_error("Unknown particle verifying method");
					break;
			}
		}
		
		// which localization method do we wish to use?
		if (p->MFlagEncountered) {
			switch (method) {
				case LOCALIZATION_METHOD_2DGAUSS:
					positions_fitter = boost::shared_ptr<FitPositions>(new FitPositions_SymmetricGaussian(initial_width, sigma));
					break;
				case LOCALIZATION_METHOD_2DGAUSS_FIXEDWIDTH:
					positions_fitter = boost::shared_ptr<FitPositions>(new FitPositions_FixedWidthGaussian(initial_width, sigma));
					break;
				case LOCALIZATION_METHOD_MULTIPLICATION:
					positions_fitter = boost::shared_ptr<FitPositions>(new FitPositionsMultiplication(initial_width, sigma));
					break;
				case LOCALIZATION_METHOD_CENTROID:
					positions_fitter = boost::shared_ptr<FitPositions>(new FitPositionsCentroid(initial_width));
					break;
				case LOCALIZATION_METHOD_2DGAUSS_ELLIPSOIDAL:
					positions_fitter = boost::shared_ptr<FitPositions>(new FitPositions_EllipsoidalGaussian(initial_width, sigma));
					break;
				default:
					throw std::runtime_error("Unknown localization method");
					break;
			}
			
		} else {
			positions_fitter = boost::shared_ptr<FitPositions>(new FitPositions_SymmetricGaussian(initial_width, sigma));
		}
		
		if (quiet == 1) {
			progressReporter = boost::shared_ptr<PALMAnalysisProgressReporter> (new PALMAnalysisProgressReporter_Silent);
		} else {
			progressReporter = boost::shared_ptr<PALMAnalysisProgressReporter> (new PALMAnalysisProgressReporter_IgorCommandLine);
		}
		analysisController = boost::shared_ptr<PALMAnalysisController> (new PALMAnalysisController(thresholder, preprocessor, 
																								   postprocessor, particle_finder, particleVerifiers,
																								   positions_fitter,
																								   progressReporter));
		
		localizedPositions = analysisController->DoPALMAnalysis(image_loader);
		localizedPositions->writePositionsToWave(outputWaveParams, analysisOptionsStream.str());
	}
	catch (std::bad_alloc) {
		err = NOMEM;
	}
	catch (int e) {
		err = e;
	}
	catch (USER_ABORTED e) {
		XOPNotice(e.what());
		err = USER_ABORT;
	}
	catch (std::runtime_error e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		err = PALM_ANALYSIS_XOP_ERROR;
	}
	catch (...) {
		err = WM_UNKNOWN_ERROR;
	}
	
	SetOperationNumVar("V_flag", err);
	
	if ((err != 0) && (returnErrors != 0)) {
		return err;
	} else {
		return 0;
	}
}


static int ExecuteReadCCDImages(ReadCCDImagesRuntimeParamsPtr p) {
	gsl_set_error_handler_off();	// we will handle errors ourselves
	int err = 0;
	int returnErrors = 1;
	int camera_type;
	size_t start_image, end_image;
	std::string data_file_path;
	int header_only = 0;
	
	boost::shared_ptr<ImageLoader> image_loader;
	
	// Flag parameters.
	
	if (p->YFlagEncountered) {
		// Parameter: p->camera_type
		camera_type = (int)(p->camera_type + 0.5);
		
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->HFlagEncountered) {
		header_only = 1;
	} else {
		header_only = 0;
	}
	
	if (p->ZFlagEncountered) {
		returnErrors = 0;
	} else {
		returnErrors = 1;
	}
	
	// Main parameters.
	
	if (p->start_imageEncountered) {
		// Parameter: p->start_image
		if (p->start_image < 0) {
			start_image = 0;
		} else {
		start_image = (size_t)(p->start_image + 0.5);
		}
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->end_imageEncountered) {
		// Parameter: p->end_image
		if (p->end_image < 0) {
			return EXPECT_POS_NUM;
		}
		end_image = (size_t)(p->end_image + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->experiment_fileEncountered) {
		// Parameter: p->experiment_file (test for NULL handle before using)
		if (p->experiment_file == NULL) {
			return EXPECTED_STRING_EXPR;
		}
		
		if (camera_type != CAMERA_TYPE_IGOR_WAVE) {
			err = ConvertHandleToFilepathString(p->experiment_file, data_file_path);
			if (err != 0) {
				return err;
			}
		} else {	// if we are loading data from an Igor wave then there is no need to convert
			err = ConvertHandleToString(p->experiment_file, data_file_path);
			if (err != 0) {
				return err;
			}
		}
		
		
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	try {
		
		// if we are here then everything should be okay
		image_loader = get_image_loader_for_camera_type(camera_type, data_file_path);
		
		if (header_only == 0) {
			err = load_partial_ccd_image(image_loader.get(), start_image, end_image);
		} else {
			err = parse_ccd_headers(image_loader.get());
		}
		
	}
	catch (std::bad_alloc) {
		err = NOMEM;
	}
	catch (int e) {
		err = e;
	}
	catch (USER_ABORTED e) {
		XOPNotice(e.what());
		err = USER_ABORT;
	}
	catch (std::runtime_error e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		err = PALM_ANALYSIS_XOP_ERROR;
	}
	catch (...) {
		err = WM_UNKNOWN_ERROR;
	}
	
	SetOperationNumVar("V_flag", err);
	
	if ((err != 0) && (returnErrors != 0)) {
		return err;
	} else {
		return 0;
	}
}


static int ExecuteProcessCCDImages(ProcessCCDImagesRuntimeParamsPtr p) {
	gsl_set_error_handler_off();	// we will handle errors ourselves
	int err = 0;
	int camera_type;
	int method;
	int overwrite = 0;	// if non-zero then we overwrite the output file if it exists
	int outputType;
	size_t startX, endX, startY, endY;
	
	double n_parameter;	// the value that corresponds to the /N flag
	
	std::string input_file_path;
	std::string output_file_path;
	
	boost::shared_ptr<ImageLoader> image_loader;
	boost::shared_ptr<ImageOutputWriter> output_writer;
	boost::shared_ptr<CCDImagesProcessor> ccd_image_processor;
	
	
	// Flag parameters.
	
	if (p->YFlagEncountered) {
		// Parameter: p->camera_type
		camera_type = (int)(p->camera_type + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->MFlagEncountered) {
		// Parameter: p->method
		if (p-> method < 0) {
			return EXPECT_POS_NUM;
		}
		method = (int)(p->method + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->NFlagEncountered) {
		// Parameter: p->method_parameter
		if ((method == PROCESSING_AVERAGESUBTRACTION) && (p->method_parameter < 0)) {
			return EXPECT_POS_NUM;
		}
		n_parameter = p->method_parameter;
		
	} else {	// we didn't encounter the /N flag
				// for now this isn't a problem, but if we implement a method
				// that requires a parameter then we have to return an error here
		
		if (method == PROCESSING_AVERAGESUBTRACTION)	// subtract an average
			n_parameter = 0;	// if we don't specify /N then we want to subtract an average for the entire trace
		
	}
	
	if (p->OUTFlagEncountered) {
		// Parameter: p->outputType
		outputType = (int)(p->outputType + 0.5);
	} else {
		outputType = IMAGE_OUTPUT_TYPE_TIFF;
	}
	
	if (p->OFlagEncountered) {
		overwrite = 1;
	}
	
	if (p->RFlagEncountered) {
		// Parameter: p->startX
		// Parameter: p->endX
		// Parameter: p->startY
		// Parameter: p->endY
		
		// check that they are all positive
		if ((p->startX < 0) || (p->endX < 0) || (p->startY < 0) || (p->endY < 0)) {
			return EXPECT_POS_NUM;
		}
		if ((p->startX >= p->endX) || (p->startY >= p->endY)) {
			return EXPECT_POS_NUM;	// update this with the proper error message
		}
		
		startX = (size_t)(p->startX + 0.5);
		endX = (size_t)(p->endX + 0.5);
		startY = (size_t)(p->startY + 0.5);
		endY = (size_t)(p->endY + 0.5);
	} else {
		if (method == PROCESSING_CROP) {	// export a cropped version
			return TOO_FEW_PARAMETERS;
		}
	}
	
	// Main parameters.
	
	if (p->input_fileEncountered) {
		// Parameter: p->input_file (test for NULL handle before using)
		if (p->input_file == NULL) {
			return EXPECTED_STRING_EXPR;
		}
		if (camera_type != CAMERA_TYPE_IGOR_WAVE) {
			err = ConvertHandleToFilepathString(p->input_file, input_file_path);
			if (err != 0) {
				return err;
			}
		} else {	// if we are loading data from an Igor wave then there is no need to convert
			err = ConvertHandleToString(p->input_file, input_file_path);
			if (err != 0) {
				return err;
			}
		}
	} else {
		return EXPECTED_STRING_EXPR;
	}
	
	if (p->output_fileEncountered) {
		// Parameter: p->output_file (test for NULL handle before using)
		if (p->output_file == NULL) {
			return EXPECTED_STRING_EXPR;
		}
		if (outputType == IMAGE_OUTPUT_TYPE_IGOR) {
			err = ConvertHandleToString(p->output_file, output_file_path);
		} else {
			err = ConvertHandleToFilepathString(p->output_file, output_file_path);
		}
		if (err != 0) {
			return err;
		}
	} else {
		return EXPECTED_STRING_EXPR;
	}
	
	
	try {
		image_loader = get_image_loader_for_camera_type(camera_type, input_file_path);
		
		switch (outputType) {
			case IMAGE_OUTPUT_TYPE_TIFF:
				// the storage type depends on the method
				switch (method) {
					case PROCESSING_AVERAGESUBTRACTION:
					case PROCESSING_DIFFERENCEIMAGE:
						output_writer = boost::shared_ptr<ImageOutputWriter>(new TIFFImageOutputWriter(output_file_path, overwrite, COMPRESSION_NONE, STORAGE_TYPE_FP32));
						break;
					default:
						output_writer = boost::shared_ptr<ImageOutputWriter>(new TIFFImageOutputWriter(output_file_path, overwrite, COMPRESSION_NONE, image_loader->getStorageType()));
						break;
				}
				break;
			case IMAGE_OUTPUT_TYPE_COMPRESSED_TIFF:
				// the storage type depends on the method
				switch (method) {
					case PROCESSING_AVERAGESUBTRACTION:
					case PROCESSING_DIFFERENCEIMAGE:
						output_writer = boost::shared_ptr<ImageOutputWriter>(new TIFFImageOutputWriter(output_file_path, overwrite, COMPRESSION_DEFLATE, STORAGE_TYPE_FP32));
						break;
					default:
						output_writer = boost::shared_ptr<ImageOutputWriter>(new TIFFImageOutputWriter(output_file_path, overwrite, COMPRESSION_DEFLATE, image_loader->getStorageType()));
						break;
				}
				break;
			case IMAGE_OUTPUT_TYPE_IGOR:
				output_writer = boost::shared_ptr<ImageOutputWriter>(new IgorImageOutputWriter(output_file_path, image_loader->get_total_number_of_images(), 
																							   overwrite));
				break;
			default:
				throw std::runtime_error("Unsupported output format (/OUT flag)");
		}
		
		// do the actual procedure
		switch (method) {
			case PROCESSING_AVERAGESUBTRACTION:		// subtract an average from the trace
				ccd_image_processor = boost::shared_ptr<CCDImagesProcessor>(new CCDImagesProcessorAverageSubtraction(image_loader.get(), output_writer.get(), 0));
				break;
			case PROCESSING_DIFFERENCEIMAGE:		// generate a difference image
				ccd_image_processor = boost::shared_ptr<CCDImagesProcessor>(new CCDImagesProcessorDifferenceImage(image_loader.get(), output_writer.get()));
				break;
			case PROCESSING_CHANGEFORMAT:		// convert to a different form (determined by the output writer)
				ccd_image_processor = boost::shared_ptr<CCDImagesProcessor>(new CCDImagesProcessorConvertToSimpleFileFormat(image_loader.get(), output_writer.get()));
				break;
			case PROCESSING_CROP:		// output a cropped version of the image
				ccd_image_processor = boost::shared_ptr<CCDImagesProcessor>(new CCDImagesProcessorCrop(image_loader.get(), output_writer.get(), startX, endX, startY, endY));
				break;
			default:
				throw std::runtime_error("Unknown CCD postprocessing method");
				break;
		}
		
		ccd_image_processor->convert_images();
	}
	
	catch (std::bad_alloc) {
		SetOperationNumVar("V_flag", NOMEM);
		return NOMEM;
	}
	catch (int e) {
		SetOperationNumVar("V_flag", e);
		return e;
	}
	catch (USER_ABORTED e) {
		XOPNotice(e.what());
		err = USER_ABORT;
	}
	catch (std::runtime_error e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		return SYNERR;
	}
	catch (...) {
		err = WM_UNKNOWN_ERROR;
	}
	
	SetOperationNumVar("V_flag", 0.0);
	return err;
}


static int ExecuteAnalyzeCCDImages(AnalyzeCCDImagesRuntimeParamsPtr p) {
	gsl_set_error_handler_off();	// we will handle errors ourselves
	int err = 0;
	int camera_type;
	int method;
	
	DataFolderAndName outputWaveParams;
	long startX, startY, endX, endY, swap;
	
	std::string input_file_path;
	
	boost::shared_ptr<ImageLoader> image_loader;
	
	// Flag parameters.
	
	if (p->YFlagEncountered) {
		// Parameter: p->camera_type
		camera_type = (int)(p->camera_type + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
		
	
	if (p->MFlagEncountered) {
		// Parameter: p->method
		method = (int)(p->method + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->RFlagEncountered) {
		// Parameter: p->startX
		// Parameter: p->endX
		// Parameter: p->startY
		// Parameter: p->endY
		
		// check that they are all positive
		if ((p->startX < 0) || (p->endX < 0) || (p->startY < 0) || (p->endY < 0)) {
			return EXPECT_POS_NUM;
		}
		if ((p->startX >= p->endX) || (p->startY >= p->endY)) {
			return EXPECT_POS_NUM;	// update this with the proper error message
		}
		
		startX = (long)(p->startX + 0.5);
		endX = (long)(p->endX + 0.5);
		startY = (long)(p->startY + 0.5);
		endY = (long)(p->endY + 0.5);
		
		if (startX < 0)
			startX = 0;
		if (startY < 0)
			startY = 0;
		if (startX > endX) {
			swap = endX;
			endX = startX;
			startX = swap;
		}
		if (startY > endY) {
			swap = endY;
			endY = startY;
			startY = swap;
		}
			
		
		
	} else {
		startX = endX = startY = endY = -1;	// by convention '-1' means that we take the whole image
	}
	
	// Main parameters.
	
	if (p->outputWaveParamsEncountered) {
		// Parameter: p->outputWaveParams
		outputWaveParams = p->outputWaveParams;
	} else {
		return EXPECTED_NAME;
	}
	
	if (p->input_fileEncountered) {
		// Parameter: p->input_file (test for NULL handle before using)
		if (p->input_fileEncountered == 0) {
			return EXPECTED_STRING_EXPR;
		}
		if (camera_type != CAMERA_TYPE_IGOR_WAVE) {
			err = ConvertHandleToFilepathString(p->input_file, input_file_path);
			if (err != 0) {
				return err;
			}
		} else {	// if we are loading data from an Igor wave then there is no need to convert
			err = ConvertHandleToString(p->input_file, input_file_path);
			if (err != 0) {
				return err;
			}
		}
		
	} else {
		return EXPECTED_STRING_EXPR;
	}
	
	try {
		image_loader = get_image_loader_for_camera_type(camera_type, input_file_path);
	
		switch (method) {
			case 0:
				err = construct_summed_intensity_trace(image_loader.get(), outputWaveParams, startX, startY, endX, endY);
				break;
			case 1:
				err = construct_average_image(image_loader.get(), outputWaveParams, startX, startY, endX, endY);
				break;
			case 2:
				calculateStandardDeviationImage(image_loader.get(), outputWaveParams, startX, startY, endX, endY);
				break;
			default:
				throw std::runtime_error("Unknown analysis method");
		}
	}
	catch (std::bad_alloc) {
		return NOMEM;
	}
	catch (int e) {
		return e;
	}
	catch (USER_ABORTED e) {
		XOPNotice(e.what());
		err = USER_ABORT;
	}
	catch (std::runtime_error e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		return SYNERR;
	}
	catch (...) {
		return WM_UNKNOWN_ERROR;
	}

	return 0;
}


static int ExecuteTestThreshold(TestThresholdRuntimeParamsPtr p) {
	gsl_set_error_handler_off();	// we will handle errors ourselves
	int err = 0;
	size_t method;
	size_t preprocessing_method, postprocessing_method;
	size_t particle_finding_method;
	size_t offset;
	int output_located_particles;
	double absoluteThreshold, PFA, PSFWidth;
	double radiusBetweenParticles;
	waveHndl CCD_Frame_wave;
	waveHndl threshold_image_wave;
	boost::shared_ptr<ublas::matrix<double> > CCD_Frame;
	boost::shared_ptr<std::list<position> > located_particles;
	std::vector<size_t> particleVerifierMethods;
	
	// long numDimensions; 
	long dimensionSizes[MAX_DIMENSIONS+1];
	long x_size, y_size;
	long indices[MAX_DIMENSIONS];
	double value[2];
	
	
	boost::shared_ptr<ublas::matrix <unsigned char> > thresholded_image;
	
	
	boost::shared_ptr<ThresholdImage> thresholder;
	boost::shared_ptr<ThresholdImage_Preprocessor> preprocessor;
	boost::shared_ptr<ThresholdImage_Postprocessor> postprocessor;
	boost::shared_ptr<ParticleFinder> particlefinder;
	std::vector<boost::shared_ptr<ParticleVerifier> > particleVerifiers;
	boost::shared_ptr<ParticleVerifier> particleVerifier;
	
	
	// Flag parameters.
	
	if (p->MFlagEncountered) {
		// Parameter: p->method
		method = (size_t)(p->method + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->ABSFlagEncountered) {
		// Parameter: p->absoluteThreshold
		absoluteThreshold = p->absoluteThreshold;
	} else if (method == THRESHOLD_METHOD_DIRECT)
		return TOO_FEW_PARAMETERS;
	
	
	if (p->PFAFlagEncountered) {
		// Parameter: p->PFA
		PFA = p->PFA;
	} else if (method == THRESHOLD_METHOD_GLRT)
		return TOO_FEW_PARAMETERS;
	
	if (p->WDTHFlagEncountered) {
		// Parameter: p->PSFWidth
		PSFWidth = p->PSFWidth;
		if (PSFWidth <= 0)
			return EXPECT_POS_NUM;
	} else
		PSFWidth = 2.0;
	
	if (p->GFlagEncountered) {
		// Parameter: p->preprocessing
		// Parameter: p->postprocessing
		preprocessing_method = (size_t)(p->preprocessing + 0.5);
		postprocessing_method = (size_t)(p->postprocessing + 0.5);
	} else {
		// if this flag doesn't appear then we assume that we don't want any pre- or postprocessing
		preprocessing_method = 0;
		postprocessing_method = 0;
	}
	
	if (p->SFlagEncountered) {
		// Parameter: p->output_located_particles
		output_located_particles = (int)(p->output_located_particles + 0.5);
	} else {
		output_located_particles = 0;
	}
	
	if (p->FFlagEncountered) {	// choose which particle finder we want to use
		// Parameter: p->particle_finder
		particle_finding_method = (size_t)(p->particle_finder + 0.5);
	} else {
		if (output_located_particles == 1)
			return TOO_FEW_PARAMETERS;
	}
	
	if (p->PVERFlagEncountered) {
		int* paramsSet = &p->PVERFlagParamsSet[0];
		size_t particleVerifierMethod;
		
		for (int i=0; i<100; i++) {
			if (paramsSet[i] == 0)
				break;		// No more parameters.
			
			particleVerifierMethod = (size_t)(p->particleVerifiers[i] + 0.5);
			
			particleVerifierMethods.push_back(particleVerifierMethod);
		}
	} else {
		particleVerifierMethods.push_back(PARTICLEVERIFIER_NONE);
	}
	
	// Main parameters.
	
	if (p->CCD_FrameEncountered) {
		// Parameter: p->CCD_Frame (test for NULL handle before using)
		if (p->CCD_Frame == NULL) {
			return NOWAV;
		} else {
			CCD_Frame_wave = p->CCD_Frame;
		}
	} else {
		return NOWAV;
	}
	
	try {
		
		// copy the Igor wave with the CCD Frame into a new gsl_matrix
		CCD_Frame = CopyIgorDPWaveToMatrix(CCD_Frame_wave);
		
		x_size = CCD_Frame->size1();
		y_size = CCD_Frame->size2();
		
		// which preprocessing do we wish to do?
		switch(preprocessing_method) {
			case PREPROCESSOR_NONE:	// no preprocessing
				// preprocessor = NULL;	// this is the default for a smart pointer
				break;
			case PREPROCESSOR_3X3MEDIAN:	// 3x3 median filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MedianFilter(3,3));
				break;
			case PREPROCESSOR_5X5MEDIAN:	// 5x5 median filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MedianFilter(5,5));
				break;
			case PREPROCESSOR_1X1GAUSSIAN:	// 1x1 Gaussian filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_GaussianSmoothing(1));
				break;
			case PREPROCESSOR_2X2GAUSSIAN:	// 2x2 Gaussian filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_GaussianSmoothing(2));
				break;
			case PREPROCESSOR_3X3MEAN:	// 3x3 mean filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MeanFilter(3,3));
				break;
			case PREPROCESSOR_5X5MEAN:	// 5x5 mean filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MeanFilter(5,5));
				break;
			default:
				throw std::runtime_error("Unknown segmentation preprocessing method");
				break;
		}
		switch(method) {
			case THRESHOLD_METHOD_GLRT:	// the GLRT test proposed by Arnauld et al in Nat Methods 5:687 2008
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_GLRT_FFT(PFA, PSFWidth));
				break;
			case THRESHOLD_METHOD_IGOR_ITERATIVE:	// Igor's iterative approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Iterative());
				break;
			case THRESHOLD_METHOD_IGOR_BIMODAL:	// Igor's iterative approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Bimodal());
				break;
			case THRESHOLD_METHOD_IGOR_ADAPTIVE:	// Igor's adaptive approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Adaptive());
				break;
			case THRESHOLD_METHOD_IGOR_FUZZY_1:	// Igor's first fuzzy approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Fuzzy1());
				break;
			case THRESHOLD_METHOD_IGOR_FUZZY_2:	// Igor's second fuzzy approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Fuzzy2());
				break;
			case THRESHOLD_METHOD_ISODATA:	// isodata algorithm (http://www.ph.tn.tudelft.nl/Courses/FIP/noframes/fip-Segmenta.html)
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Isodata());
				break;
			case THRESHOLD_METHOD_TRIANGLE:	// modified triangle algorithm (http://www.ph.tn.tudelft.nl/Courses/FIP/noframes/fip-Segmenta.html)
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Triangle());
				break;
			case THRESHOLD_METHOD_DIRECT:	// direct threshold
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Direct(absoluteThreshold));
				break;
			default:
				throw std::runtime_error("Unknown segmentation method");
				break;
		}
		
		
		// which postprocessing do we wish to do?
		switch(postprocessing_method) {
			case POSTPROCESSOR_NONE:	// no postprocessing
				//postprocessor = NULL;	// this is the default for a shared_ptr
				break;
			case POSTPROCESSOR_REMOVE_ISOLATED_PIXELS:	// remove isolated pixels
				postprocessor = boost::shared_ptr<ThresholdImage_Postprocessor>(new ThresholdImage_Postprocessor_RemoveIsolatedPixels());
				break;
			default:
				throw std::runtime_error("Unknown segmentation postprocessing method");
				break;
		}
		
		// do we wish to show the located particle positions?
		// which method do we want to use?
		if (output_located_particles == 1) {
			switch (particle_finding_method) {
				case PARTICLEFINDER_ADJACENT4:
					particlefinder = boost::shared_ptr<ParticleFinder>(new ParticleFinder_adjacent4());
					break;
				case PARTICLEFINDER_ADJACENT8:
					particlefinder = boost::shared_ptr<ParticleFinder>(new ParticleFinder_adjacent8());
					break;
				case PARTICLEFINDER_RADIUS:	// traditional radius approach
					particlefinder = boost::shared_ptr<ParticleFinder>(new ParticleFinder_radius(radiusBetweenParticles));
					break;
				default:
					throw std::runtime_error("Unknown particle finding method");
					break;
			}
			
			// what particle verification do we wish to use?
			// several particle verifiers can be used
			for (std::vector<size_t>::iterator it = particleVerifierMethods.begin(); it != particleVerifierMethods.end(); ++it) {
				switch (*it) {
					case PARTICLEVERIFIER_NONE:
						// no particle verification requested for this entry, do nothing
						break;
					case PARTICLEVERIFIER_SYMMETRICGAUSS:
						particleVerifiers.push_back(boost::shared_ptr<ParticleVerifier> (new ParticleVerifier_SymmetricGaussian(PSFWidth, 1)));
						break;
					case PARTICLEVERIFIER_ELLIPSOIDALGAUSS:
						particleVerifiers.push_back(boost::shared_ptr<ParticleVerifier> (new ParticleVerifier_EllipsoidalGaussian(PSFWidth, 1)));
						break;
					case PARTICLEVERIFIER_REMOVEOVERLAPPINGPARTICLES:
						particleVerifiers.push_back(boost::shared_ptr<ParticleVerifier> (new ParticleVerifier_RemoveOverlappingParticles(PSFWidth)));
						break;
					default:
						throw std::runtime_error("Unknown particle verifying method");
						break;
				}
			}
		}
		
		
		
		// calculate the threshold
		thresholded_image = do_processing_and_thresholding(CCD_Frame, preprocessor, thresholder, postprocessor);
		
		// now create the output wave
		dimensionSizes[0] = x_size;
		dimensionSizes[1] = y_size;
		dimensionSizes[2] = 0;
		
		threshold_image_wave = MakeWaveUsingFullPath(std::string("M_ImageThresh"), dimensionSizes, NT_I8 | NT_UNSIGNED, 1);
		
		for (long i = 0; i < x_size; i++) {
			for (long j = 0; j < y_size; j++) {
				indices[0] = i;
				indices[1] = j;
				
				value[0] = (double)((*thresholded_image)(i, j));
				
				err = MDSetNumericWavePointValue(threshold_image_wave, indices, value);
				if (err != 0) {
					return err;
				}
			}
		}
		
		// if it is requested then output the positions
		if (output_located_particles == 1) {
			located_particles = particlefinder->findPositions(CCD_Frame, thresholded_image);
			
			// if the located particles are to be verified before fitting then do so
			for (std::vector<boost::shared_ptr<ParticleVerifier> >::iterator it = particleVerifiers.begin(); it != particleVerifiers.end(); ++it) {
				(*it)->VerifyParticles(CCD_Frame, located_particles);
			}
			
			long dimensionSizes[MAX_DIMENSIONS+1];
			long indices[MAX_DIMENSIONS];
			waveHndl outputWave;
			size_t nParticles = (*located_particles).size();
			dimensionSizes[0] = nParticles;
			dimensionSizes[1] = 4;	// warning: magic number
			dimensionSizes[2] = 0;
			double value[2];
			
			outputWave = MakeWaveUsingFullPath(std::string("M_locatedParticles"), dimensionSizes, NT_FP64, 1);
			
			offset = 0;
			for (std::list<position>::iterator it = located_particles->begin(); it != located_particles->end(); ++it) {
				indices[0] = offset;
				indices[1] = 0;
				value[0] = (*it).get_intensity();
				MDSetNumericWavePointValue(outputWave, indices, value);
				indices[1] = 1;
				value[0] = (*it).get_x();
				MDSetNumericWavePointValue(outputWave, indices, value);
				indices[1] = 2;
				value[0] = (*it).get_y();
				MDSetNumericWavePointValue(outputWave, indices, value);
				indices[1] = 3;
				value[0] = (*it).get_background();
				MDSetNumericWavePointValue(outputWave, indices, value);
				++offset;
			}
		}
		
	}
	
	catch (std::bad_alloc) {
		return NOMEM;
	}
	catch (int e) {
		return e;
	}
	catch (USER_ABORTED e) {
		XOPNotice(e.what());
		err = USER_ABORT;
	}
	catch (std::runtime_error e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		return PALM_ANALYSIS_XOP_ERROR;
	}
	catch (...) {
		return WM_UNKNOWN_ERROR;
	}
	
	return err;
}


static int ExecuteConvolveImages(ConvolveImagesRuntimeParamsPtr p) {
	gsl_set_error_handler_off();	// we will handle errors ourselves
	int err = 0;
	boost::shared_ptr<ublas::matrix<double> > firstImage;
	boost::shared_ptr<ublas::matrix<double> > secondImage;
	boost::shared_ptr<ublas::matrix<double> > outputImage;
	waveHndl firstWave;
	waveHndl secondWave;
	waveHndl outputWave;
	
	// Main parameters.
	
	if (p->firstImageEncountered) {
		// Parameter: p->firstImage (test for NULL handle before using)
		if (p->firstImage == NULL) {
			return NOWAV;
		}
		firstWave = p->firstImage;
	} else {
		return NOWAV;
	}
	
	if (p->secondImageEncountered) {
		// Parameter: p->secondImage (test for NULL handle before using)
		if (p->firstImage == NULL) {
			return NOWAV;
		}
		secondWave = p->secondImage;
	} else {
		return NOWAV;
	}
	
	try {
		firstImage = CopyIgorDPWaveToMatrix(firstWave);
		secondImage = CopyIgorDPWaveToMatrix(secondWave);
		ConvolveMatricesWithFFTClass matrixConvolver;
		
		outputImage = matrixConvolver.ConvolveMatricesWithFFT(firstImage,secondImage);
		
		outputWave = CopyMatrixToIgorDPWave(outputImage, "M_Convolved");
		
	}
	catch (std::bad_alloc) {
		return NOMEM;
	}
	catch (int e) {
		return e;
	}
	catch (USER_ABORTED e) {
		XOPNotice(e.what());
		err = USER_ABORT;
	}
	catch (std::runtime_error e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		return PALM_ANALYSIS_XOP_ERROR;
	}
	catch (...) {
		return WM_UNKNOWN_ERROR;
	}
	
	return err;
}


static int ExecuteMakeBitmapPALMImage(MakeBitmapPALMImageRuntimeParamsPtr p) {
	gsl_set_error_handler_off();	// we will handle errors ourselves
	int err = 0;
	int method, emitterWeighing;
	double scaleFactor, upperLimit, PSFWidth;
	size_t imageWidth, imageHeight, xSize, ySize;
	
	waveHndl positionsWave;
	
	boost::shared_ptr<PALMBitmapImageCalculator> imageCalculator;
	boost::shared_ptr<PALMBitmapImageDeviationCalculator> deviationCalculator;
	boost::shared_ptr<PALMAnalysisProgressReporter> progressReporter;
	boost::shared_ptr<ublas::matrix <double> > image;
	
	// Flag parameters.
	
	if (p->MFlagEncountered) {
		// Parameter: p->deviationMethod
		if (p->deviationMethod < 0) {
			return EXPECT_POS_NUM;
		}
		
		method = (int)(p->deviationMethod + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->SFlagEncountered) {
		// Parameter: p->scaleFactor
		if (p->scaleFactor <= 0)
			return EXPECT_POS_NUM;
		scaleFactor = p->scaleFactor;
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->LFlagEncountered) {
		// Parameter: p->upperLimit
		if (p->upperLimit <= 0)
			return EXPECT_POS_NUM;
		upperLimit = p->upperLimit;
	} else {
		if (method == PALMBITMAP_DEVIATION_FITUNCERTAINTY) {	// calculate the width using the uncertainty from the fits
			return TOO_FEW_PARAMETERS;
		}
	}
	
	if (p->WFlagEncountered) {
		// Parameter: p->CCDXSize
		// Parameter: p->CCDYSize
		// Parameter: p->ImageWidth
		// Parameter: p->ImageHeight
		if ((p->CCDXSize <= 0) || (p->CCDYSize <= 0) || (p->ImageWidth <= 0) || (p->ImageHeight <= 0))
			return EXPECT_POS_NUM;
		xSize = (size_t)(p->CCDXSize + 0.5);
		ySize = (size_t)(p->CCDYSize + 0.5);
		imageWidth = (size_t)(p->ImageWidth + 0.5);
		imageHeight = (size_t)(p->ImageHeight + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->WGHTFlagEncountered) {
		// Parameter: p->emitterWeighing
		emitterWeighing = int(p->emitterWeighing + 0.5);
		if ((emitterWeighing != 0) && (emitterWeighing != 1)) {
			return EXPECT_POS_NUM;
		}
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->PFlagEncountered) {
		// Parameter: p->PSFWidth
		if (p->PSFWidth <= 0) {
			return EXPECT_POS_NUM;
		}
		
		PSFWidth = p->PSFWidth;
		
	} else {
		if (method == PALMBITMAP_DEVIATION_INTEGRALSQUAREROOT) {
			return TOO_FEW_PARAMETERS;
		}
	}
	
	// Main parameters.	
	if (p->positionsWaveEncountered) {
		// Parameter: p->positionsWave (test for NULL handle before using)
		if (p->positionsWave == NULL) {
			return NOWAV;
		}
		positionsWave = p->positionsWave;
	} else {
		return NOWAV;
	}
	
	try {
		// get the object that will calculate the standard deviation
		switch (method) {
			case PALMBITMAP_DEVIATION_SAME:
				deviationCalculator = boost::shared_ptr<PALMBitmapImageDeviationCalculator> (new PALMBitmapImageDeviationCalculator_Constant(scaleFactor));
				break;
			case PALMBITMAP_DEVIATION_FITUNCERTAINTY:
				deviationCalculator = boost::shared_ptr<PALMBitmapImageDeviationCalculator> (new PALMBitmapImageDeviationCalculator_FitUncertainty(scaleFactor, upperLimit));
				break;
			case PALMBITMAP_DEVIATION_INTEGRALSQUAREROOT:
				deviationCalculator = boost::shared_ptr<PALMBitmapImageDeviationCalculator> (new PALMBitmapImageDeviationCalculator_IntegralSquareRoot(PSFWidth, scaleFactor));
				break;
			default:
				throw std::runtime_error("Unknown deviation calculation method (/M flag)");
		}
	
	// do the actual calculation
		progressReporter = boost::shared_ptr<PALMAnalysisProgressReporter> (new PALMAnalysisProgressReporter_IgorCommandLine);
		imageCalculator = boost::shared_ptr<PALMBitmapImageCalculator>(new PALMBitmapImageCalculator(deviationCalculator, emitterWeighing, progressReporter));
		boost::shared_ptr<LocalizedPositionsContainer> positions(LocalizedPositionsContainer::GetPositionsFromWave(positionsWave));
		image = imageCalculator->CalculateImage(positions, xSize, ySize, imageWidth, imageHeight);
		CopyMatrixToIgorDPWave(image, std::string("M_PALM"));
	}
	catch (std::bad_alloc) {
		return NOMEM;
	}
	catch (int e) {
		return e;
	}
	catch (USER_ABORTED e) {
		XOPNotice(e.what());
		err = USER_ABORT;
	}
	catch (std::runtime_error e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		return PALM_ANALYSIS_XOP_ERROR;
	}
	catch (...) {
		return WM_UNKNOWN_ERROR;
	}
	
	return err;
}

static int ExecuteRipleyLFunctionClustering(RipleyLFunctionClusteringRuntimeParamsPtr p) {
	int err = 0;
	size_t nBins;
	double binWidth, calculationRange;
	
	// Flag parameters.
	
	if (p->RNGEFlagEncountered) {
		// Parameter: p->calculationRange
		// Parameter: p->nBins
		if ((p->calculationRange <= 0) || (p->nBins <= 0))
			return EXPECT_POS_NUM;
		
		calculationRange = p->calculationRange;
		nBins = (size_t)(p->nBins + 0.5);
		
	} else {
		return EXPECT_POS_NUM;
	}
	
	double lowerX = 0, upperX = 0, lowerY = 0, upperY = 0;
	if (p->REGNFlagEncountered) {
		// Parameter: p->lowerX
		// Parameter: p->upperX
		// Parameter: p->lowerY
		// Parameter: p->upperY
		lowerX = p->lowerX;
		upperX = p->upperX;
		lowerY = p->lowerY;
		upperY = p->upperY;
	}
	
	// Main parameters.
	
	if (p->positionsWaveEncountered) {
		// Parameter: p->positionsWave (test for NULL handle before using)
		if (p->positionsWave == NULL)
			return NOWAV;
	}
	
	
	
	try {
		boost::shared_ptr<LocalizedPositionsContainer> positions = LocalizedPositionsContainer::GetPositionsFromWave(p->positionsWave);
		boost::shared_ptr<std::vector<double> > kFunction = CalculateLFunctionClustering(positions, calculationRange, nBins, lowerX, upperX, lowerY, upperY);
		
		binWidth = calculationRange / (double)nBins;
		double dimOffset = binWidth;
		double dimDelta = binWidth;
		waveHndl outputWave = CopyVectorToIgorDPWave(kFunction, std::string("W_LFunction"));
		err = MDSetWaveScaling(outputWave, 0, &dimDelta, &dimOffset);
	}
	catch (USER_ABORTED e) {
		XOPNotice(e.what());
		err = USER_ABORT;
	}
	catch (std::runtime_error e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		return PALM_ANALYSIS_XOP_ERROR;
	}
	catch (int e) {
		return e;
	}
	catch (...) {
		XOPNotice("An unknown error occurred\r");
		return WM_UNKNOWN_ERROR;
	}
	
	return err;
}

static int RegisterAnalyzePALMImages(void) {
	const char* cmdTemplate;
	const char* runtimeNumVarList;
	const char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the AnalyzePALMImagesRuntimeParams structure as well.
	cmdTemplate = "AnalyzePALMImages /M=number:method /D=number:thresholding_method /Y=number:camera_type /G={number:preprocessing, number:postprocessing} /F=number:particle_finder /PVER={number[100]:particleVerifiers} /T=number:treshold_parameter /PFA=number:PFA /R=number:radius /W=number:initial_width /S=number:sigma /P=wave:positions_wave /Q /Z DataFolderAndName:{outputWaveParams, real}, string:experiment_file";
	runtimeNumVarList = "V_flag;";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(AnalyzePALMImagesRuntimeParams), (void*)ExecuteAnalyzePALMImages, 0);
}

static int RegisterReadCCDImages(void) {
	const char* cmdTemplate;
	const char* runtimeNumVarList;
	const char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the ReadCCDImagesRuntimeParams structure as well.
	cmdTemplate = "ReadCCDImages /Y=number:camera_type /H /Z number:start_image, number:end_image, string:experiment_file";
	runtimeNumVarList = "V_flag;V_numberOfImages;V_xSize;V_ySize;V_firstImageLoaded;V_lastImageLoaded;";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(ReadCCDImagesRuntimeParams), (void*)ExecuteReadCCDImages, kOperationIsThreadSafe);
}

static int RegisterProcessCCDImages(void) {
	const char* cmdTemplate;
	const char* runtimeNumVarList;
	const char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the ProcessCCDImagesRuntimeParams structure as well.
	cmdTemplate = "ProcessCCDImages /Y=number:camera_type /M=number:method /N=number:method_parameter /R={number:startX, number:endX, number:startY, number:endY} /OUT=number:outputType /O string:input_file, string:output_file";
	runtimeNumVarList = "V_flag";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(ProcessCCDImagesRuntimeParams), (void*)ExecuteProcessCCDImages, 0);
}

static int RegisterAnalyzeCCDImages(void) {
	const char* cmdTemplate;
	const char* runtimeNumVarList;
	const char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the AnalyzeCCDImagesRuntimeParams structure as well.
	cmdTemplate = "AnalyzeCCDImages /Y=number:camera_type /M=number:method /R={number:startX, number:endX, number:startY, number:endY} DataFolderAndName:{outputWaveParams, real}, string:input_file";
	runtimeNumVarList = "";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(AnalyzeCCDImagesRuntimeParams), (void*)ExecuteAnalyzeCCDImages, 0);
}

static int RegisterTestThreshold(void) {
	const char* cmdTemplate;
	const char* runtimeNumVarList;
	const char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the TestThresholdRuntimeParams structure as well.
	cmdTemplate = "TestThreshold /M=number:method /ABS=number:absoluteThreshold /PFA=number:PFA /WDTH=number:PSFWidth /G={number:preprocessing, number:postprocessing} /F=number:particle_finder /PVER={number[100]:particleVerifiers} /R=number:radiusBetweenParticles /S=number:output_located_particles wave:CCD_Frame";
	runtimeNumVarList = "";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(TestThresholdRuntimeParams), (void*)ExecuteTestThreshold, 0);
}

static int RegisterConvolveImages(void) {
	const char* cmdTemplate;
	const char* runtimeNumVarList;
	const char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the ConvolveImagesRuntimeParams structure as well.
	cmdTemplate = "ConvolveImages wave:firstImage, wave:secondImage";
	runtimeNumVarList = "";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(ConvolveImagesRuntimeParams), (void*)ExecuteConvolveImages, 0);
}

static int RegisterMakeBitmapPALMImage(void) {
	const char* cmdTemplate;
	const char* runtimeNumVarList;
	const char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the MakeBitmapPALMImageRuntimeParams structure as well.
	cmdTemplate = "MakeBitmapPALMImage /M=number:deviationMethod /S=number:scaleFactor /L=number:upperLimit /W={number:CCDXSize, number:CCDYSize, number:ImageWidth, number:ImageHeight} /WGHT=number:emitterWeighing /P=number:PSFWidth wave:positionsWave";
	runtimeNumVarList = "";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(MakeBitmapPALMImageRuntimeParams), (void*)ExecuteMakeBitmapPALMImage, 0);
}


static int RegisterRipleyLFunctionClustering(void) {
	const char* cmdTemplate;
	const char* runtimeNumVarList;
	const char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the RipleyLFunctionClusteringRuntimeParams structure as well.
	cmdTemplate = "RipleyLFunctionClustering /RNGE={number:calculationRange, number:nBins} /REGN={number:lowerX, number:upperX, number:lowerY, number:upperY} wave:positionsWave";
	runtimeNumVarList = "";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(RipleyLFunctionClusteringRuntimeParams), (void*)ExecuteRipleyLFunctionClustering, 0);
}

/*	XOPEntry()
 
 This is the entry point from the host application to the XOP for all
 messages after the INIT message.
 */
static void XOPEntry(void) {	
	long result = 0;
	
	switch (GetXOPMessage()) {
			// We don't need to handle any messages for this XOP.
	}
	SetXOPResult(result);
}

static int RegisterOperations(void)		// Register any operations with Igor.
{
	int result;
	
	if (result = RegisterAnalyzePALMImages())
		return result;
	if (result = RegisterReadCCDImages())
		return result;
	if (result = RegisterProcessCCDImages())
		return result;
	if (result = RegisterAnalyzeCCDImages())
		return result;
	if (result = RegisterTestThreshold())
		return result;
	if (result = RegisterConvolveImages())
		return result;
	if (result = RegisterMakeBitmapPALMImage())
		return result;
	if (result = RegisterRipleyLFunctionClustering())
		return result;
	
	// There are no more operations added by this XOP.
	
	return 0;
}


/*	main(ioRecHandle)
 
 This is the initial entry point at which the host application calls XOP.
 The message sent by the host must be INIT.
 
 main does any necessary initialization and then sets the XOPEntry field of the
 ioRecHandle to the address to be called for future messages.
 */
HOST_IMPORT int main(IORecHandle ioRecHandle) {
	int result;
	
	XOPInit(ioRecHandle);							// Do standard XOP initialization.
	
	SetXOPEntry(XOPEntry);							// Set entry point for future calls.
	
	if (result = RegisterOperations()) {
		SetXOPResult(result);
	}
	else {
		SetXOPResult(0);
	}
}

class INCOMPATIBLE_WAVE_FORMAT {};


boost::shared_ptr<ImageLoader> get_image_loader_for_camera_type(size_t camera_type, std::string data_file_path) {
	
	boost::shared_ptr<ImageLoader> image_loader;
	
	switch (camera_type) {
		case CAMERA_TYPE_WINSPEC:	// spe files
			image_loader = boost::shared_ptr<ImageLoader>(new ImageLoaderSPE(data_file_path));
			break;
		case CAMERA_TYPE_ANDOR:
			image_loader = boost::shared_ptr<ImageLoader>(new ImageLoaderAndor(data_file_path));
			break;
		case CAMERA_TYPE_HAMAMATSU:
			image_loader = boost::shared_ptr<ImageLoader>(new ImageLoaderHamamatsu(data_file_path));
			break;
		case CAMERA_TYPE_TIFF:	// 3 is reserved for TIFF files
			image_loader = boost::shared_ptr<ImageLoader>(new ImageLoaderTIFF(data_file_path));
			break;
		case CAMERA_TYPE_SIMPLE:
			image_loader = boost::shared_ptr<ImageLoader>(new SimpleImageLoader(data_file_path));
			break;
		case CAMERA_TYPE_ZEISS:	// Zeiss lsm files
			image_loader = boost::shared_ptr<ImageLoader>(new ImageLoaderTIFF(data_file_path));
			break;
		case CAMERA_TYPE_IGOR_WAVE: // Matrix wave in Igor
			image_loader = boost::shared_ptr<ImageLoader>(new ImageLoaderIgor(data_file_path));
			break;
		default:
			throw std::runtime_error("Unsupported CCD file type (/Y flag)");
			break;
	}
	
	return image_loader;
	
}

