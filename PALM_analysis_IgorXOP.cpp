/*
 *  PALM_analysis_IgorXOP.cpp
 *  PALM analysis
 *
 *  Created by Peter Dedecker on 05/01/2008.
 *  Copyright 2008 __MyCompanyName__. All rights reserved.
 *
 */

#include "PALM_analysis_IgorXOP.h"

using namespace std;

// the framework below was generated by Igor

// Runtime param structure for AnalyzePALMImages operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct AnalyzePALMImagesRuntimeParams {
// Flag parameters.

// Parameters for /M flag group.
int MFlagEncountered;
double method;
int MFlagParamsSet[1];

// Parameters for /D flag group.
int DFlagEncountered;
double thresholding_method;
int DFlagParamsSet[1];

// Parameters for /Y flag group.
int YFlagEncountered;
double camera_type;
int YFlagParamsSet[1];

// Parameters for /G flag group.
int GFlagEncountered;
double preprocessing;
double postprocessing;
int GFlagParamsSet[2];

// Parameters for /F flag group.
int FFlagEncountered;
double particle_finder;
int FFlagParamsSet[1];

// Parameters for /T flag group.
int TFlagEncountered;
double treshold_parameter;
int TFlagParamsSet[1];

// Parameters for /B flag group.
int BFlagEncountered;
double background;
int BFlagParamsSet[1];

// Parameters for /R flag group.
int RFlagEncountered;
double radius;
int RFlagParamsSet[1];

// Parameters for /W flag group.
int WFlagEncountered;
double initial_width;
int WFlagParamsSet[1];

// Parameters for /E flag group.
int EFlagEncountered;
double min_distance_from_edge;
int EFlagParamsSet[1];

// Parameters for /C flag group.
int CFlagEncountered;
double cutoff_radius;
int CFlagParamsSet[1];

// Parameters for /S flag group.
int SFlagEncountered;
double sigma;
int SFlagParamsSet[1];

// Parameters for /P flag group.
int PFlagEncountered;
waveHndl positions_wave;
int PFlagParamsSet[1];

// Main parameters.

// Parameters for simple main group #0.
int name_of_output_waveEncountered;
char name_of_output_wave[MAX_OBJ_NAME+1];
int name_of_output_waveParamsSet[1];

// Parameters for simple main group #1.
int experiment_fileEncountered;
Handle experiment_file;
int experiment_fileParamsSet[1];

// These are postamble fields that Igor sets.
int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
};
typedef struct AnalyzePALMImagesRuntimeParams AnalyzePALMImagesRuntimeParams;
typedef struct AnalyzePALMImagesRuntimeParams* AnalyzePALMImagesRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.

// Runtime param structure for ReadCCDImages operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct ReadCCDImagesRuntimeParams {
	// Flag parameters.
	
	// Parameters for /Y flag group.
	int YFlagEncountered;
	double camera_type;
	int YFlagParamsSet[1];
	
	// Parameters for /H flag group.
	int HFlagEncountered;
	// There are no fields for this group because it has no parameters.
	
	// Main parameters.
	
	// Parameters for simple main group #0.
	int start_imageEncountered;
	double start_image;
	int start_imageParamsSet[1];
	
	// Parameters for simple main group #1.
	int end_imageEncountered;
	double end_image;
	int end_imageParamsSet[1];
	
	// Parameters for simple main group #2.
	int experiment_fileEncountered;
	Handle experiment_file;
	int experiment_fileParamsSet[1];
	
	// These are postamble fields that Igor sets.
	int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
	int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
	struct tag_UserFuncThreadInfo *tp;		// If not null, we are running from a ThreadSafe function.
};
typedef struct ReadCCDImagesRuntimeParams ReadCCDImagesRuntimeParams;
typedef struct ReadCCDImagesRuntimeParams* ReadCCDImagesRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.

// Runtime param structure for ProcessCCDImages operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct ProcessCCDImagesRuntimeParams {
	// Flag parameters.
	
	// Parameters for /Y flag group.
	int YFlagEncountered;
	double camera_type;
	int YFlagParamsSet[1];
	
	// Parameters for /M flag group.
	int MFlagEncountered;
	double method;
	int MFlagParamsSet[1];
	
	// Parameters for /N flag group.
	int NFlagEncountered;
	double method_parameter;
	int NFlagParamsSet[1];
	
	// Parameters for /O flag group.
	int OFlagEncountered;
	// There are no fields for this group because it has no parameters.
	
	// Main parameters.
	
	// Parameters for simple main group #0.
	int input_fileEncountered;
	Handle input_file;
	int input_fileParamsSet[1];
	
	// Parameters for simple main group #1.
	int output_fileEncountered;
	Handle output_file;
	int output_fileParamsSet[1];
	
	// These are postamble fields that Igor sets.
	int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
	int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
};
typedef struct ProcessCCDImagesRuntimeParams ProcessCCDImagesRuntimeParams;
typedef struct ProcessCCDImagesRuntimeParams* ProcessCCDImagesRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.

// Runtime param structure for AnalyzeCCDImages operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct AnalyzeCCDImagesRuntimeParams {
	// Flag parameters.
	
	// Parameters for /Y flag group.
	int YFlagEncountered;
	double camera_type;
	int YFlagParamsSet[1];
	
	// Parameters for /M flag group.
	int MFlagEncountered;
	double method;
	int MFlagParamsSet[1];
	
	// Parameters for /R flag group.
	int RFlagEncountered;
	double RFlagNumber0;
	double RFlagNumber1;
	double RFlagNumber2;
	double RFlagNumber3;
	int RFlagParamsSet[4];
	
	// Main parameters.
	
	// Parameters for simple main group #0.
	int output_waveEncountered;
	char output_wave[MAX_OBJ_NAME+1];
	int output_waveParamsSet[1];
	
	// Parameters for simple main group #1.
	int input_fileEncountered;
	Handle input_file;
	int input_fileParamsSet[1];
	
	// These are postamble fields that Igor sets.
	int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
	int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
};
typedef struct AnalyzeCCDImagesRuntimeParams AnalyzeCCDImagesRuntimeParams;
typedef struct AnalyzeCCDImagesRuntimeParams* AnalyzeCCDImagesRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.

// Runtime param structure for TestThreshold operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct TestThresholdRuntimeParams {
	// Flag parameters.
	
	// Parameters for /M flag group.
	int MFlagEncountered;
	double method;
	int MFlagParamsSet[1];
	
	// Parameters for /T flag group.
	int TFlagEncountered;
	double parameter;
	int TFlagParamsSet[1];
	
	// Parameters for /P flag group.
	int PFlagEncountered;
	double parameter2;
	int PFlagParamsSet[1];
	
	// Parameters for /G flag group.
	int GFlagEncountered;
	double preprocessing;
	double postprocessing;
	int GFlagParamsSet[2];
	
	// Parameters for /F flag group.
	int FFlagEncountered;
	double particle_finder;
	int FFlagParamsSet[1];
	
	// Parameters for /R flag group.
	int RFlagEncountered;
	double radiusBetweenParticles;
	int RFlagParamsSet[1];
	
	// Parameters for /S flag group.
	int SFlagEncountered;
	double output_located_particles;
	int SFlagParamsSet[1];
	
	// Main parameters.
	
	// Parameters for simple main group #0.
	int CCD_FrameEncountered;
	waveHndl CCD_Frame;
	int CCD_FrameParamsSet[1];
	
	// These are postamble fields that Igor sets.
	int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
	int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
};
typedef struct TestThresholdRuntimeParams TestThresholdRuntimeParams;
typedef struct TestThresholdRuntimeParams* TestThresholdRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.

// Runtime param structure for ConvolveImages operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct ConvolveImagesRuntimeParams {
	// Flag parameters.
	
	// Main parameters.
	
	// Parameters for simple main group #0.
	int firstImageEncountered;
	waveHndl firstImage;
	int firstImageParamsSet[1];
	
	// Parameters for simple main group #1.
	int secondImageEncountered;
	waveHndl secondImage;
	int secondImageParamsSet[1];
	
	// These are postamble fields that Igor sets.
	int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
	int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
};
typedef struct ConvolveImagesRuntimeParams ConvolveImagesRuntimeParams;
typedef struct ConvolveImagesRuntimeParams* ConvolveImagesRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.


// Runtime param structure for MakeBitmapPALMImage operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct MakeBitmapPALMImageRuntimeParams {
	// Flag parameters.
	
	// Parameters for /M flag group.
	int MFlagEncountered;
	double deviationMethod;
	int MFlagParamsSet[1];
	
	// Parameters for /S flag group.
	int SFlagEncountered;
	double scaleFactor;
	int SFlagParamsSet[1];
	
	// Parameters for /L flag group.
	int LFlagEncountered;
	double upperLimit;
	int LFlagParamsSet[1];
	
	// Parameters for /W flag group.
	int WFlagEncountered;
	double CCDXSize;
	double CCDYSize;
	double ImageWidth;
	double ImageHeight;
	int WFlagParamsSet[4];
	
	// Main parameters.
	
	// Parameters for simple main group #0.
	int colorWaveEncountered;
	waveHndl colorWave;
	int colorWaveParamsSet[1];
	
	// Parameters for simple main group #1.
	int positionsWaveEncountered;
	waveHndl positionsWave;
	int positionsWaveParamsSet[1];
	
	// These are postamble fields that Igor sets.
	int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
	int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
};
typedef struct MakeBitmapPALMImageRuntimeParams MakeBitmapPALMImageRuntimeParams;
typedef struct MakeBitmapPALMImageRuntimeParams* MakeBitmapPALMImageRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.


static int ExecuteAnalyzePALMImages(AnalyzePALMImagesRuntimeParamsPtr p) {
	int err = 0;
	double threshold_parameter, radiusBetweenParticles, initial_width, min_distance_from_edge, cutoff_radius, sigma, background;
	string name_of_output_wave;
	string data_file_path;
	unsigned long camera_type;
	int method;
	int particle_finding_method;
	int fitting_positions_supplied_in_wave = 0;	// determines if we have to determine the positions to fit in ourselves, or if we can read them from the wave
	long numDimensions;
	long dimensionSizes[MAX_DIMENSIONS + 1];
	waveHndl fitting_positions = NULL;
	
	unsigned long preprocessing_method;
	unsigned long thresholding_method;
	unsigned long postprocessing_method;
	
	boost::shared_ptr<ImageLoader> image_loader;
	boost::shared_ptr<FitPositions> positions_fitter;
	boost::shared_ptr<ThresholdImage> thresholder;
	boost::shared_ptr<ThresholdImage_Preprocessor> preprocessor;
	boost::shared_ptr<ThresholdImage_Postprocessor> postprocessor;
	boost::shared_ptr<ParticleFinder> particle_finder;
	
	// SOME STUFF THAT WE HAVE TO GET OUT OF THE WAY
	if (sizeof(char) != 1)
		return SIZE_OF_CHAR_IS_NOT_ONE_BYTE_DEF;
	if (sizeof(float) != 4)
		return SIZE_OF_FLOAT_IS_NOT_FOUR_BYTES_DEF;
	
	
	// Flag parameters.
	
	if (p->MFlagEncountered) {
		// Parameter: p->method
		
		// 0 means Gaussian fitting
		// 1 means multiplication method (Thompson, Biophys J 2002)
		method = (int)(p->method + 0.5);
	}
	
	if (p->DFlagEncountered) {
		// Parameter: p->thresholding_method
		thresholding_method = (int)(p->thresholding_method + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->YFlagEncountered) {
		// Parameter: p->camera_type
		camera_type = (unsigned long)(p->camera_type + 0.5);
	}
	
	if (p->GFlagEncountered) {
		// Parameter: p->preprocessing
		// Parameter: p->postprocessing
		preprocessing_method = (unsigned long)(p->preprocessing + 0.5);
		postprocessing_method = (unsigned long)(p->postprocessing + 0.5);
	} else {
		// if this flag doesn't appear then we assume that we don't want any pre- or postprocessing
		preprocessing_method = 0;
		postprocessing_method = 0;
	}
	
	if (p->FFlagEncountered) {
		// Parameter: p->particle_finder
		particle_finding_method = (int)(p->particle_finder + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->TFlagEncountered) {
		// Parameter: p->treshold_parameter
		threshold_parameter = p->treshold_parameter;
	} else {
		if ((thresholding_method == 0) || (thresholding_method == 8)) {
			return TOO_FEW_PARAMETERS;
		}
	}
	
	if (p->BFlagEncountered) {
		// Parameter: p->background
		background = p->background;
	} else {
		background = 1000;
	}
	
	if (p->RFlagEncountered) {
		// Parameter: p->radius
		radiusBetweenParticles = p->radius;
	} else {
		radiusBetweenParticles = 10;
	}
	
	if (p->WFlagEncountered) {
		// Parameter: p->initial_width
		initial_width = p->initial_width;
	} else {
		initial_width = 4;
	}
	
	if (p->EFlagEncountered) {
		// Parameter: p->min_distance_from_edge
		min_distance_from_edge = p->min_distance_from_edge;
	} else {
		min_distance_from_edge = 11;
	}
	
	if (p->CFlagEncountered) {
		// Parameter: p->cutoff_radius
		cutoff_radius = p->cutoff_radius;
	} else {
		cutoff_radius = 10;
	}
	
	if (p->SFlagEncountered) {
		// Parameter: p->sigma
		sigma = p->sigma;
	} else {
		sigma = 1;
	}
	
	if (p->PFlagEncountered) {
		// Parameter: p->positions_wave (test for NULL handle before using)
		if (p->positions_wave == NULL) {
			return NOWAV;
		}
		
		fitting_positions = p->positions_wave;
		
		if (WaveType(fitting_positions) != NT_FP64) {
			return NT_INCOMPATIBLE;
		}
		
		err = MDGetWaveDimensions(fitting_positions, &numDimensions, dimensionSizes);
		if (err != 0) {
			return err;
		}
		
		if ((numDimensions != 2) || (dimensionSizes[1] != 3)) {
			return INCOMPATIBLE_DIMENSIONING;
		}
		
		fitting_positions_supplied_in_wave = 1;
	} else {
		fitting_positions_supplied_in_wave = 0;
	}
	
	// Main parameters.
	
	if (p->name_of_output_waveEncountered) {
		// Parameter: p->name_of_output_wave
		name_of_output_wave.assign(p->name_of_output_wave);
	} else {
		return EXPECTED_NAME;
	}
	
	try {
		
		if (p->experiment_fileEncountered) {
			// Parameter: p->experiment_file (test for NULL handle before using)
			if (p->experiment_file == NULL) {
				return EXPECTED_STRING_EXPR;
			}
			
			err = convert_handle_to_string(p->experiment_file, data_file_path);
			if (err != 0) {
				return err;
			}
			
			image_loader = get_image_loader_for_camera_type(camera_type, data_file_path);
			
		} else {	// file path parameter was not supplied from igor
			return EXPECTED_STRING_EXPR;
		}
		
		
		// which preprocessing do we wish to do?
		switch(preprocessing_method) {
			case 0:	// no preprocessing
				//preprocessor = NULL;	// this is the default for a shared_ptr
				break;
			case 1:	// 3x3 median filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MedianFilter(3,3));
				break;
			case 2:	// 5x5 median filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MedianFilter(5,5));
				break;
			case 3:	// 1x1 Gaussian filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_GaussianSmoothing(1));
				break;
			case 4:	// 2x2 Gaussian filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_GaussianSmoothing(2));
				break;
			case 5:	// 3x3 mean filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MeanFilter(3,3));
				break;
			case 6:	// 5x5 mean filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MeanFilter(5,5));
				break;
			default:
				return UNKNOWN_THRESHOLD_PREPROCESSING_METHOD;
				break;
		}
		
		
		// choose which thresholding we want to do
		switch(thresholding_method) {
			case 0:	// direct threshold
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Direct(threshold_parameter));
				break;
			case 1:	// Igor's iterative approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Iterative());
				break;
			case 2:	// Igor's iterative approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Bimodal());
				break;
			case 3:	// Igor's adaptive approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Adaptive());
				break;
			case 4:	// Igor's first fuzzy approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Fuzzy1());
				break;
			case 5:	// Igor's second fuzzy approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Fuzzy2());
				break;
			case 6:	// isodata algorithm (http://www.ph.tn.tudelft.nl/Courses/FIP/noframes/fip-Segmenta.html)
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Isodata());
				break;
			case 7:	// modified triangle algorithm (http://www.ph.tn.tudelft.nl/Courses/FIP/noframes/fip-Segmenta.html)
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Triangle());
				break;
			case 8:	// the GLRT test proposed by Arnauld et al in Nat Methods 5:687 2008
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_GLRT_FFT(threshold_parameter, initial_width));
				break;
			default:
				return UNKNOWN_CCD_IMAGES_PROCESSING_METHOD;
				break;
		}
		
		// which postprocessing do we wish to do?
		switch(postprocessing_method) {
			case 0:	// no postprocessing
				//postprocessor = NULL;	// this is the default for a shared_ptr
				break;
			case 1:	// remove isolated pixels
				postprocessor = boost::shared_ptr<ThresholdImage_Postprocessor>(new ThresholdImage_Postprocessor_RemoveIsolatedPixels());
				break;
			case 2:	// reject 'on' pixels that have values below the intensity mean of the image
				postprocessor = boost::shared_ptr<ThresholdImage_Postprocessor>(new ThresholdImage_Postprocessor_RemovePixelsBelowMean());
				break;
			default:
				return UNKNOWN_THRESHOLD_POSTPROCESSING_METHOD;
				break;
		}
		
		// which particle finding method do we wish to use?
		switch (particle_finding_method) {
			case 0:
				particle_finder = boost::shared_ptr<ParticleFinder>(new ParticleFinder_adjacent4(min_distance_from_edge));
				break;
			case 1:
				particle_finder = boost::shared_ptr<ParticleFinder>(new ParticleFinder_adjacent8(min_distance_from_edge));
				break;
			case 2:	// traditional radius approach
				particle_finder = boost::shared_ptr<ParticleFinder>(new ParticleFinder_radius(min_distance_from_edge, radiusBetweenParticles));
				break;
			default:
				return UNKNOWN_CCD_IMAGES_PROCESSING_METHOD;
				break;
		}
		
		
		// which localization method do we wish to use?
		if (p->MFlagEncountered) {
			switch (method) {
				case 0:
					positions_fitter = boost::shared_ptr<FitPositions>(new FitPositionsGaussian(cutoff_radius, initial_width, background, sigma));
					break;
					
				case 1:
					positions_fitter = boost::shared_ptr<FitPositions>(new FitPositionsMultiplication(cutoff_radius, initial_width, background, sigma));
					break;
				case 2:
					positions_fitter = boost::shared_ptr<FitPositions>(new FitPositionsCentroid(cutoff_radius));
					break;
				default:
					return UNKNOWN_CCD_IMAGES_PROCESSING_METHOD;
					break;
			}
			
		} else {
			positions_fitter = boost::shared_ptr<FitPositions>(new FitPositionsGaussian(cutoff_radius, initial_width, background, sigma));
		}
		
		if (fitting_positions_supplied_in_wave == 0) {
			do_analyze_images_operation_parallel(image_loader, name_of_output_wave, positions_fitter, particle_finder, preprocessor, thresholder, postprocessor);
			
		} else {	// we need to use the positions supplied in the wave fitting_positions to do the fit
			do_analyze_images_operation_no_positions_finding(image_loader, name_of_output_wave, fitting_positions, positions_fitter);
		}
	}
	catch (std::bad_alloc) {
		return NOMEM;
	}
	catch (OUT_OF_MEMORY err) {
		XOPNotice(err.get_error().c_str());
		return NOMEM;
	}
	catch (CANNOT_OPEN_FILE) {
		return CANNOT_OPEN_FILE_DEF;
	}
	catch (ERROR_READING_FILE_DATA e) {
		XOPNotice(e.get_error().c_str());
		return ERROR_READING_FILE_DATA_DEF;
	}
	catch (END_SHOULD_BE_LARGER_THAN_START) {
		return END_SHOULD_BE_LARGER_THAN_START_DEF;
	}
	catch (std::range_error err) {
		XOPNotice(err.what());
	}
	catch (IMAGE_INDEX_BEYOND_N_IMAGES) {
		return IMAGE_INDEX_BEYOND_N_IMAGES_DEF;
	}
	catch (int e) {
		return e;
	}
	
	return 0;
}


static int ExecuteReadCCDImages(ReadCCDImagesRuntimeParamsPtr p) {
	int err = 0;
	int camera_type;
	unsigned long start_image, end_image;
	std::string data_file_path;
	int header_only = 0;
	
	boost::shared_ptr<ImageLoader> image_loader;
	
	
	// SOME STUFF THAT WE HAVE TO GET OUT OF THE WAY
	if (sizeof(char) != 1)
		return SIZE_OF_CHAR_IS_NOT_ONE_BYTE_DEF;
	if (sizeof(float) != 4)
		return SIZE_OF_FLOAT_IS_NOT_FOUR_BYTES_DEF;
		
	
	// Flag parameters.
	
	if (p->YFlagEncountered) {
		// Parameter: p->camera_type
		camera_type = (int)(p->camera_type + 0.5);
		
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->HFlagEncountered) {
		header_only = 1;
	} else {
		header_only = 0;
	}
	
	// Main parameters.
	
	if (p->start_imageEncountered) {
		// Parameter: p->start_image
		if (p->start_image < 0) {
			start_image = 0;
		} else {
		start_image = (unsigned long)(p->start_image + 0.5);
		}
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->end_imageEncountered) {
		// Parameter: p->end_image
		if (p->end_image < 0) {
			return EXPECT_POS_NUM;
		}
		end_image = (unsigned long)(p->end_image + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->experiment_fileEncountered) {
		// Parameter: p->experiment_file (test for NULL handle before using)
		if (p->experiment_file == NULL) {
			return EXPECTED_STRING_EXPR;
		}
		err = convert_handle_to_string(p->experiment_file, data_file_path);
		if (err != 0) {
			return err;
		}
		
		
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	try {
		
		// if we are here then everything should be okay
		if ((end_image > start_image) && (end_image - start_image < N_SIMULTANEOUS_IMAGE_LOADS))	// if we only want to load a small number of images
																									// then there's no point to fill up the full cache each time
			image_loader = get_image_loader_for_camera_type(camera_type, data_file_path, end_image - start_image);
		else
			image_loader = get_image_loader_for_camera_type(camera_type, data_file_path);
		
		if (header_only == 0) {
			err = load_partial_ccd_image(image_loader.get(), start_image, end_image);
		} else {
			err = parse_ccd_headers(image_loader.get());
		}
		
	}
	catch (std::bad_alloc) {
		return NOMEM;
	}
	catch (OUT_OF_MEMORY err) {
		XOPNotice(err.get_error().c_str());
		return NOMEM;
	}
	catch (CANNOT_OPEN_FILE) {
		return CANNOT_OPEN_FILE_DEF;
	}
	catch (ERROR_READING_FILE_DATA e) {
		XOPNotice(e.get_error().c_str());
		return ERROR_READING_FILE_DATA_DEF;
	}
	catch (END_SHOULD_BE_LARGER_THAN_START) {
		return END_SHOULD_BE_LARGER_THAN_START_DEF;
	}
	catch (std::range_error err) {
		XOPNotice(err.what());
		return INDEX_OUT_OF_RANGE;
	}
	catch (int e) {
		return e;
	}
	catch (IMAGE_INDEX_BEYOND_N_IMAGES) {
		return IMAGE_INDEX_BEYOND_N_IMAGES_DEF;
	}
	
	return err;
}


static int ExecuteProcessCCDImages(ProcessCCDImagesRuntimeParamsPtr p) {
	int err = 0;
	int camera_type;
	int method;
	int overwrite = 0;	// if non-zero then we overwrite the output file if it exists
	
	double n_parameter;	// the value that corresponds to the /N flag
	
	string input_file_path;
	string output_file_path;
	
	boost::shared_ptr<ImageLoader> image_loader;
	boost::shared_ptr<OutputWriter> output_writer;
	boost::shared_ptr<CCDImagesProcessor> ccd_image_processor;
	
	// SOME STUFF THAT WE HAVE TO GET OUT OF THE WAY
	if (sizeof(char) != 1)
		return SIZE_OF_CHAR_IS_NOT_ONE_BYTE_DEF;
	if (sizeof(float) != 4)
		return SIZE_OF_FLOAT_IS_NOT_FOUR_BYTES_DEF;
	
	
	
	// Flag parameters.
	
	if (p->YFlagEncountered) {
		// Parameter: p->camera_type
		camera_type = (int)(p->camera_type + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->MFlagEncountered) {
		// Parameter: p->method
		if (p-> method < 0) {
			return EXPECT_POS_NUM;
		}
		method = (int)(p->method + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->NFlagEncountered) {
		// Parameter: p->method_parameter
		if ((method == 0) && (p->method_parameter < 0)) {
			return EXPECT_POS_NUM;
		}
		n_parameter = p->method_parameter;
		
	} else {	// we didn't encounter the /N flag
				// for now this isn't a problem, but if we implement a method
				// that requires a parameter then we have to return an error here
		
		if (method == 0)	// subtract an average
			n_parameter = 0;	// if we don't specify /N then we want to subtract an average for the entire trace
		
	}
	
	if (p->OFlagEncountered) {
		overwrite = 1;
	}
	
	// Main parameters.
	
	if (p->input_fileEncountered) {
		// Parameter: p->input_file (test for NULL handle before using)
		if (p->input_file == NULL) {
			return EXPECTED_STRING_EXPR;
		}
		err = convert_handle_to_string(p->input_file, input_file_path);
		if (err != 0) {
			return err;
		}
	} else {
		return EXPECTED_STRING_EXPR;
	}
	
	if (p->output_fileEncountered) {
		// Parameter: p->output_file (test for NULL handle before using)
		if (p->output_file == NULL) {
			return EXPECTED_STRING_EXPR;
		}
		err = convert_handle_to_string(p->output_file, output_file_path);
		if (err != 0) {
			return err;
		}
	} else {
		return EXPECTED_STRING_EXPR;
	}
	
	
	try {
		image_loader = get_image_loader_for_camera_type(camera_type, input_file_path);
		
		output_writer = boost::shared_ptr<OutputWriter>(new TIFFOutputWriter(output_file_path, overwrite));
		
		
		// do the actual procedure
		switch (method) {
			case 0:		// subtract an average from the trace
				ccd_image_processor = boost::shared_ptr<CCDImagesProcessor>(new CCDImagesProcessorAverageSubtraction(image_loader.get(), output_writer.get()));
				break;
			case 1:		// generate a difference image
				ccd_image_processor = boost::shared_ptr<CCDImagesProcessor>(new CCDImagesProcessorDifferenceImage(image_loader.get(), output_writer.get()));
				break;
			case 2:		// convert to the simple pde file format
				ccd_image_processor = boost::shared_ptr<CCDImagesProcessor>(new CCDImagesProcessorConvertToSimpleFileFormat(image_loader.get(), output_writer.get()));
				break;
			default:
				return UNKNOWN_CCD_IMAGES_PROCESSING_METHOD;
				break;
		}
		
		ccd_image_processor->convert_images();
	}
	
	catch (std::bad_alloc) {
		return NOMEM;
	}
	catch (OUT_OF_MEMORY err) {
		XOPNotice(err.get_error().c_str());
		return NOMEM;
	}
	catch (CANNOT_OPEN_FILE) {
		return CANNOT_OPEN_FILE_DEF;
	}
	catch (ERROR_READING_FILE_DATA e) {
		XOPNotice(e.get_error().c_str());
		return ERROR_READING_FILE_DATA_DEF;
	}
	catch (ERROR_WRITING_FILE_DATA e) {
		XOPNotice(e.get_error().c_str());
		return ERROR_WRITING_FILE_DATA_DEF;
	}
	catch (END_SHOULD_BE_LARGER_THAN_START) {
		return END_SHOULD_BE_LARGER_THAN_START_DEF;
	}
	catch (std::range_error err) {
		XOPNotice(err.what());
		return INDEX_OUT_OF_RANGE;
	}
	catch (IMAGE_INDEX_BEYOND_N_IMAGES) {
		return IMAGE_INDEX_BEYOND_N_IMAGES_DEF;
	}
	catch (int e) {
		return e;
	}
	
	
	return err;
}


static int ExecuteAnalyzeCCDImages(AnalyzeCCDImagesRuntimeParamsPtr p) {
	int err = 0;
	int camera_type;
	int method;
	
	long startX, startY, endX, endY, swap;
	
	string input_file_path;
	string name_of_output_wave;
	
	boost::shared_ptr<ImageLoader> image_loader;
	
	// Flag parameters.
	
	if (p->YFlagEncountered) {
		// Parameter: p->camera_type
		camera_type = (int)(p->camera_type + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
		
	
	if (p->MFlagEncountered) {
		// Parameter: p->method
		method = (int)(p->method + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->RFlagEncountered) {
		// Parameter: p->RFlagNumber0
		// Parameter: p->RFlagNumber0
		// Parameter: p->RFlagNumber0
		// Parameter: p->RFlagNumber0
		
		// check that they are all positive
		if ((p->RFlagNumber0 < 0) || (p->RFlagNumber1 < 0) || (p->RFlagNumber2 < 0) || (p->RFlagNumber3 < 0)) {
			return EXPECT_POS_NUM;
		}
		if ((p->RFlagNumber1 >= p->RFlagNumber3) || (p->RFlagNumber0 >= p->RFlagNumber2)) {
			return EXPECT_POS_NUM;	// update this with the proper error message
		}
		
		startX = (long)(p->RFlagNumber0 + 0.5);
		startY = (long)(p->RFlagNumber1 + 0.5);
		endX = (long)(p->RFlagNumber2 + 0.5);
		endY = (long)(p->RFlagNumber3 + 0.5);
		
		if (startX < 0)
			startX = 0;
		if (startY < 0)
			startY = 0;
		if (startX > endX) {
			swap = endX;
			endX = startX;
			startX = swap;
		}
		if (startY > endY) {
			swap = endY;
			endY = startY;
			startY = swap;
		}
			
		
		
	} else {
		startX = endX = startY = endY = -1;	// by convention '-1' means that we take the whole image
	}
	
	// Main parameters.
	
	if (p->output_waveEncountered) {
		// Parameter: p->output_wave
		name_of_output_wave.assign(p->output_wave);
	} else {
		return EXPECTED_NAME;
	}
	
	if (p->input_fileEncountered) {
		// Parameter: p->input_file (test for NULL handle before using)
		if (p->input_fileEncountered == 0) {
			return EXPECTED_STRING_EXPR;
		}
		err = convert_handle_to_string(p->input_file, input_file_path);
		if (err != 0) {
			return err;
		}
		
	} else {
		return EXPECTED_STRING_EXPR;
	}
	
	try {
		image_loader = get_image_loader_for_camera_type(camera_type, input_file_path);
	
		switch (method) {
			case 0:
				err = construct_summed_intensity_trace(image_loader.get(), name_of_output_wave, startX, startY, endX, endY);
				break;
			case 1:
				err = construct_average_image(image_loader.get(), name_of_output_wave, startX, startY, endX, endY);
				break;
			case 2:
				calculateStandardDeviationImage(image_loader.get(), name_of_output_wave, startX, startY, endX, endY);
				break;
			default:
				return UNKNOWN_CCD_IMAGES_ANALYSIS_METHOD;
		}
	}
	catch (std::bad_alloc) {
		return NOMEM;
	}
	catch (OUT_OF_MEMORY err) {
		XOPNotice(err.get_error().c_str());
		return NOMEM;
	}
	catch (CANNOT_OPEN_FILE) {
		return CANNOT_OPEN_FILE_DEF;
	}
	catch (ERROR_READING_FILE_DATA e) {
		XOPNotice(e.get_error().c_str());
		return ERROR_READING_FILE_DATA_DEF;
	}
	catch (END_SHOULD_BE_LARGER_THAN_START) {
		return END_SHOULD_BE_LARGER_THAN_START_DEF;
	}
	catch (std::range_error err) {
		XOPNotice(err.what());
		return INDEX_OUT_OF_RANGE;
	}
	catch (IMAGE_INDEX_BEYOND_N_IMAGES) {
		return IMAGE_INDEX_BEYOND_N_IMAGES_DEF;
	}
	catch (int e) {
		return e;
	}

	return 0;
}


static int ExecuteTestThreshold(TestThresholdRuntimeParamsPtr p) {
	int err = 0;
	unsigned long method;
	unsigned long preprocessing_method, postprocessing_method;
	unsigned long particle_finding_method;
	int output_located_particles;
	double parameter, parameter2;
	double radiusBetweenParticles;
	waveHndl CCD_Frame_wave;
	waveHndl threshold_image_wave;
	boost::shared_ptr<encap_gsl_matrix> CCD_Frame;
	boost::shared_ptr<encap_gsl_matrix> located_particles;
	
	// long numDimensions; 
	long dimensionSizes[MAX_DIMENSIONS+1];
	long x_size, y_size;
	long indices[MAX_DIMENSIONS];
	double value[2];
	
	
	boost::shared_ptr<encap_gsl_matrix_uchar> thresholded_image;
	
	
	boost::shared_ptr<ThresholdImage> thresholder;
	boost::shared_ptr<ThresholdImage_Preprocessor> preprocessor;
	boost::shared_ptr<ThresholdImage_Postprocessor> postprocessor;
	boost::shared_ptr<ParticleFinder> particlefinder;
	
	
	// Flag parameters.
	
	if (p->MFlagEncountered) {
		// Parameter: p->method
		method = (unsigned long)(p->method + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->TFlagEncountered) {
		// Parameter: p->parameter
		parameter = p->parameter;
	} else {
		if ((method == 0) || (method == 8)) {
			return TOO_FEW_PARAMETERS;
		}
	}
	
	if (p->PFlagEncountered) {
		// Parameter: p->parameter2
		parameter2 = p->parameter2;
	} else {
		if (method == 8) {
			return TOO_FEW_PARAMETERS;
		}
	}
	
	if (p->GFlagEncountered) {
		// Parameter: p->preprocessing
		// Parameter: p->postprocessing
		preprocessing_method = (unsigned long)(p->preprocessing + 0.5);
		postprocessing_method = (unsigned long)(p->postprocessing + 0.5);
	} else {
		// if this flag doesn't appear then we assume that we don't want any pre- or postprocessing
		preprocessing_method = 0;
		postprocessing_method = 0;
	}
	
	if (p->SFlagEncountered) {
		// Parameter: p->output_located_particles
		output_located_particles = (int)(p->output_located_particles + 0.5);
	} else {
		output_located_particles = 0;
	}
	
	if (p->FFlagEncountered) {	// choose which particle finder we want to use
		// Parameter: p->particle_finder
		particle_finding_method = (unsigned long)(p->particle_finder + 0.5);
	} else {
		if (output_located_particles == 1)
			return TOO_FEW_PARAMETERS;
	}
	
	if (p->RFlagEncountered) {
		// Parameter: p->radiusBetweenParticles
		radiusBetweenParticles = p->radiusBetweenParticles;
		if ((radiusBetweenParticles <= 0) && (particle_finding_method = 0)) {
			return EXPECT_POS_NUM;
		}
	} else {
		if (particle_finding_method == 0) {
			return TOO_FEW_PARAMETERS;
		}
	}
			
		
	
	// Main parameters.
	
	if (p->CCD_FrameEncountered) {
		// Parameter: p->CCD_Frame (test for NULL handle before using)
		if (p->CCD_Frame == NULL) {
			return NOWAV;
		} else {
			CCD_Frame_wave = p->CCD_Frame;
		}
	} else {
		return NOWAV;
	}
	
	try {
		
		// copy the Igor wave with the CCD Frame into a new gsl_matrix
		CCD_Frame = copy_IgorDPWave_to_gsl_matrix(CCD_Frame_wave);
		
		x_size = CCD_Frame->get_x_size();
		y_size = CCD_Frame->get_y_size();
		
		// which preprocessing do we wish to do?
		switch(preprocessing_method) {
			case 0:	// no preprocessing
				// preprocessor = NULL;	// this is the default for a smart pointer
				break;
			case 1:	// 3x3 median filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MedianFilter(3,3));
				break;
			case 2:	// 5x5 median filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MedianFilter(5,5));
				break;
			case 3:	// 1x1 Gaussian filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_GaussianSmoothing(1));
				break;
			case 4:	// 2x2 Gaussian filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_GaussianSmoothing(2));
				break;
			case 5:	// 3x3 mean filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MeanFilter(3,3));
				break;
			case 6:	// 5x5 mean filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MeanFilter(5,5));
				break;
			default:
				return UNKNOWN_THRESHOLD_PREPROCESSING_METHOD;
				break;
		}
		switch(method) {
			case 0:	// direct threshold
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Direct(parameter));
				break;
			case 1:	// Igor's iterative approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Iterative());
				break;
			case 2:	// Igor's iterative approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Bimodal());
				break;
			case 3:	// Igor's adaptive approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Adaptive());
				break;
			case 4:	// Igor's first fuzzy approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Fuzzy1());
				break;
			case 5:	// Igor's second fuzzy approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Fuzzy2());
				break;
			case 6:	// isodata algorithm (http://www.ph.tn.tudelft.nl/Courses/FIP/noframes/fip-Segmenta.html)
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Isodata());
				break;
			case 7:	// modified triangle algorithm (http://www.ph.tn.tudelft.nl/Courses/FIP/noframes/fip-Segmenta.html)
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Triangle());
				break;
			case 8:	// the GLRT test proposed by Arnauld et al in Nat Methods 5:687 2008
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_GLRT_FFT(parameter, parameter2));
				break;
			default:
				return UNKNOWN_CCD_IMAGES_PROCESSING_METHOD;
				break;
		}
		
		
		// which postprocessing do we wish to do?
		switch(postprocessing_method) {
			case 0:	// no postprocessing
				//postprocessor = NULL;	// this is the default for a shared_ptr
				break;
			case 1:	// remove isolated pixels
				postprocessor = boost::shared_ptr<ThresholdImage_Postprocessor>(new ThresholdImage_Postprocessor_RemoveIsolatedPixels());
				break;
			case 2:	// reject 'on' pixels that have values below the intensity mean of the image
				postprocessor = boost::shared_ptr<ThresholdImage_Postprocessor>(new ThresholdImage_Postprocessor_RemovePixelsBelowMean());
				break;
			default:
				return UNKNOWN_THRESHOLD_POSTPROCESSING_METHOD;
				break;
		}
		
		// do we wish to show the located particle positions?
		// which method do we want to use?
		if (output_located_particles == 1) {
			switch (particle_finding_method) {
				case 0:
					particlefinder = boost::shared_ptr<ParticleFinder>(new ParticleFinder_adjacent4(10));
					break;
				case 1:
					particlefinder = boost::shared_ptr<ParticleFinder>(new ParticleFinder_adjacent8(10));
					break;
				case 2:	// traditional radius approach
					particlefinder = boost::shared_ptr<ParticleFinder>(new ParticleFinder_radius(10, radiusBetweenParticles));
					break;
				default:
					return UNKNOWN_CCD_IMAGES_PROCESSING_METHOD;
					break;
			}
		}
		
		
		
		// calculate the threshold
		thresholded_image = do_processing_and_thresholding(CCD_Frame, preprocessor, thresholder, postprocessor);
		
		// now create the output wave
		dimensionSizes[0] = x_size;
		dimensionSizes[1] = y_size;
		dimensionSizes[2] = 0;
		
		err = MDMakeWave(&threshold_image_wave, "M_ImageThresh", NULL, dimensionSizes, NT_I8 | NT_UNSIGNED, 1);
		if (err != 0) {
			return err;
		}
		
		for (long j = 0; j < y_size; j++) {
			for (long i = 0; i < x_size; i++) {
				indices[0] = i;
				indices[1] = j;
				
				value[0] = (double)(thresholded_image->get(i, j));
				
				err = MDSetNumericWavePointValue(threshold_image_wave, indices, value);
				if (err != 0) {
					return err;
				}
			}
		}
		
		// if it is requested then output the positions
		if (output_located_particles == 1) {
			located_particles = particlefinder->findPositions(CCD_Frame, thresholded_image);
			
			string output_name = "M_locatedParticles";
			copy_gsl_matrix_to_IgorDPWave(located_particles, output_name);
		}
		
	}
	
	catch (std::bad_alloc) {
		return NOMEM;
	}
	catch (OUT_OF_MEMORY err) {
		XOPNotice(err.get_error().c_str());
		return NOMEM;
	}
	catch (CANNOT_OPEN_FILE) {
		return CANNOT_OPEN_FILE_DEF;
	}
	catch (ERROR_READING_FILE_DATA e) {
		XOPNotice(e.get_error().c_str());
		return ERROR_READING_FILE_DATA_DEF;
	}
	catch (END_SHOULD_BE_LARGER_THAN_START) {
		return END_SHOULD_BE_LARGER_THAN_START_DEF;
	}
	catch (std::range_error err) {
		XOPNotice(err.what());
		return INDEX_OUT_OF_RANGE;
	}
	catch (int e) {
		return e;
	}
	
	return err;
}


static int ExecuteConvolveImages(ConvolveImagesRuntimeParamsPtr p) {
	int err = 0;
	boost::shared_ptr<encap_gsl_matrix> firstImage;
	boost::shared_ptr<encap_gsl_matrix> secondImage;
	boost::shared_ptr<encap_gsl_matrix> outputImage;
	waveHndl firstWave;
	waveHndl secondWave;
	waveHndl outputWave;
	
	// Main parameters.
	
	if (p->firstImageEncountered) {
		// Parameter: p->firstImage (test for NULL handle before using)
		if (p->firstImage == NULL) {
			return NOWAV;
		}
		firstWave = p->firstImage;
	} else {
		return NOWAV;
	}
	
	if (p->secondImageEncountered) {
		// Parameter: p->secondImage (test for NULL handle before using)
		if (p->firstImage == NULL) {
			return NOWAV;
		}
		secondWave = p->secondImage;
	} else {
		return NOWAV;
	}
	
	try {
		firstImage = copy_IgorDPWave_to_gsl_matrix(firstWave);
		secondImage = copy_IgorDPWave_to_gsl_matrix(secondWave);
		ConvolveMatricesWithFFTClass matrixConvolver;
		
		outputImage = matrixConvolver.ConvolveMatricesWithFFT(firstImage,secondImage);
		
		outputWave = copy_gsl_matrix_to_IgorDPWave(outputImage, "M_Convolved");
		
	}
	catch (std::bad_alloc) {
		return NOMEM;
	}
	catch (OUT_OF_MEMORY err) {
		XOPNotice(err.get_error().c_str());
		return NOMEM;
	}
	catch (CANNOT_OPEN_FILE) {
		return CANNOT_OPEN_FILE_DEF;
	}
	catch (ERROR_READING_FILE_DATA e) {
		XOPNotice(e.get_error().c_str());
		return ERROR_READING_FILE_DATA_DEF;
	}
	catch (END_SHOULD_BE_LARGER_THAN_START) {
		return END_SHOULD_BE_LARGER_THAN_START_DEF;
	}
	catch (std::range_error err) {
		XOPNotice(err.what());
		return INDEX_OUT_OF_RANGE;
	}
	catch (int e) {
		return e;
	}
	
	return err;
}


static int ExecuteMakeBitmapPALMImage(MakeBitmapPALMImageRuntimeParamsPtr p) {
	int err = 0;
	int method;
	double scaleFactor, upperLimit;
	
	waveHndl colorWave, positionsWave;
	
	boost::shared_ptr<PALMBitmapImageDeviationCalculator> deviationCalculator;
	boost::shared_ptr<encap_gsl_matrix> positions;
	boost::shared_ptr<encap_gsl_matrix> colors;
	
	long dimensionSizes[MAX_DIMENSIONS+1];
	long numDimensions;
	
	// Flag parameters.
	
	if (p->MFlagEncountered) {
		// Parameter: p->deviationMethod
		if (p->deviationMethod <= 0) {
			return EXPECT_POS_NUM;
		}
		
		method = (int)(p->deviationMethod + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->SFlagEncountered) {
		// Parameter: p->scaleFactor
		if (p->scaleFactor <= 0)
			return EXPECT_POS_NUM;
		scaleFactor = p->scaleFactor;
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->LFlagEncountered) {
		// Parameter: p->upperLimit
		if (p->upperLimit <= 0)
			return EXPECT_POS_NUM;
		upperLimit = p->upperLimit;
	} else {
		if (method == 1) {	// calculate the width using the uncertainty from the fits
			return TOO_FEW_PARAMETERS;
		}
	}
	
	if (p->WFlagEncountered) {
		// Parameter: p->CCDXSize
		// Parameter: p->CCDYSize
		// Parameter: p->ImageWidth
		// Parameter: p->ImageHeight
	}
	
	// Main parameters.
	
	if (p->colorWaveEncountered) {
		// Parameter: p->colorWave (test for NULL handle before using)
		if (p->colorWave == NULL)
			return NOWAV;
		colorWave = p->colorWave;
		
		err = MDGetWaveDimensions(colorWave, &numDimensions, dimensionSizes);
		if (err != 0)
			return err;
		if (numDimensions != 2)
			return INCOMPATIBLE_DIMENSIONING;
		if (dimensionSizes[1] != 3)
			return INCOMPATIBLE_DIMENSIONING;
		
		colors = copy_IgorDPWave_to_gsl_matrix(colorWave);
		
	} else {
		return NOWAV;
	}
	
	if (p->positionsWaveEncountered) {
		// Parameter: p->positionsWave (test for NULL handle before using)
		if (p->positionsWave == NULL) {
			return NOWAV;
		}
		
		positionsWave = p->positionsWave;
		
		err = MDGetWaveDimensions(positionsWave, &numDimensions, dimensionSizes);
		if (err != 0)
			return err;
		if (numDimensions != 2)
			return INCOMPATIBLE_DIMENSIONING;
		if (dimensionSizes[1] != N_OUTPUT_PARAMS_PER_FITTED_POSITION + 1)
			return INCOMPATIBLE_DIMENSIONING;
		
		positions = copy_IgorDPWave_to_gsl_matrix(positionsWave);
		
	} else {
		return NOWAV;
	}
	
	
	// get the object that will calculate the standard deviation
	switch (method) {
		case 0:
			deviationCalculator = boost::shared_ptr<PALMBitmapImageDeviationCalculator> (new PALMBitmapImageDeviationCalculator_AmplitudeSquareRoot(scaleFactor));
			break;
		case 1:
			deviationCalculator = boost::shared_ptr<PALMBitmapImageDeviationCalculator> (new PALMBitmapImageDeviationCalculator_FitUncertainty(scaleFactor, upperLimit));
			break;
		case 2:
			deviationCalculator = boost::shared_ptr<PALMBitmapImageDeviationCalculator> (new PALMBitmapImageDeviationCalculator_Constant(scaleFactor));
			break;
		default:
			return UNKNOWN_CCD_IMAGES_PROCESSING_METHOD;
	}
	
	// do the actual calculation
	
	return err;
}


static int RegisterAnalyzePALMImages(void) {
	char* cmdTemplate;
	char* runtimeNumVarList;
	char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the AnalyzePALMImagesRuntimeParams structure as well.
	cmdTemplate = "AnalyzePALMImages /M=number:method /D=number:thresholding_method /Y=number:camera_type /G={number:preprocessing, number:postprocessing} /F=number:particle_finder /T=number:treshold_parameter /B=number:background /R=number:radius /W=number:initial_width /E=number:min_distance_from_edge /C=number:cutoff_radius /S=number:sigma /P=wave:positions_wave name:name_of_output_wave, string:experiment_file";
	runtimeNumVarList = "";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(AnalyzePALMImagesRuntimeParams), (void*)ExecuteAnalyzePALMImages, 0);
}

static int RegisterReadCCDImages(void) {
	char* cmdTemplate;
	char* runtimeNumVarList;
	char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the ReadCCDImagesRuntimeParams structure as well.
	cmdTemplate = "ReadCCDImages /Y=number:camera_type /H number:start_image, number:end_image, string:experiment_file";
	runtimeNumVarList = "";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(ReadCCDImagesRuntimeParams), (void*)ExecuteReadCCDImages, kOperationIsThreadSafe);
}

static int RegisterProcessCCDImages(void) {
	char* cmdTemplate;
	char* runtimeNumVarList;
	char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the ProcessCCDImagesRuntimeParams structure as well.
	cmdTemplate = "ProcessCCDImages /Y=number:camera_type /M=number:method /N=number:method_parameter /O string:input_file, string:output_file";
	runtimeNumVarList = "";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(ProcessCCDImagesRuntimeParams), (void*)ExecuteProcessCCDImages, 0);
}

static int RegisterAnalyzeCCDImages(void) {
	char* cmdTemplate;
	char* runtimeNumVarList;
	char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the AnalyzeCCDImagesRuntimeParams structure as well.
	cmdTemplate = "AnalyzeCCDImages /Y=number:camera_type /M=number:method /R={number, number, number, number} name:output_wave, string:input_file";
	runtimeNumVarList = "";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(AnalyzeCCDImagesRuntimeParams), (void*)ExecuteAnalyzeCCDImages, 0);
}

static int RegisterTestThreshold(void) {
	char* cmdTemplate;
	char* runtimeNumVarList;
	char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the TestThresholdRuntimeParams structure as well.
	cmdTemplate = "TestThreshold /M=number:method /T=number:parameter /P=number:parameter2 /G={number:preprocessing, number:postprocessing} /F=number:particle_finder /R=number:radiusBetweenParticles /S=number:output_located_particles wave:CCD_Frame";
	runtimeNumVarList = "";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(TestThresholdRuntimeParams), (void*)ExecuteTestThreshold, 0);
}

static int RegisterConvolveImages(void) {
	char* cmdTemplate;
	char* runtimeNumVarList;
	char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the ConvolveImagesRuntimeParams structure as well.
	cmdTemplate = "ConvolveImages wave:firstImage, wave:secondImage";
	runtimeNumVarList = "";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(ConvolveImagesRuntimeParams), (void*)ExecuteConvolveImages, 0);
}

static int RegisterMakeBitmapPALMImage(void) {
	char* cmdTemplate;
	char* runtimeNumVarList;
	char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the MakeBitmapPALMImageRuntimeParams structure as well.
	cmdTemplate = "MakeBitmapPALMImage /M=number:deviationMethod /S=number:scaleFactor /L=number:upperLimit /W={number:CCDXSize, number:CCDYSize, number:ImageWidth, number:ImageHeight} wave:colorWave, wave:positionsWave";
	runtimeNumVarList = "";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(MakeBitmapPALMImageRuntimeParams), (void*)ExecuteMakeBitmapPALMImage, 0);
}

/*	XOPEntry()
 
 This is the entry point from the host application to the XOP for all
 messages after the INIT message.
 */
static void XOPEntry(void) {	
	long result = 0;
	
	switch (GetXOPMessage()) {
			// We don't need to handle any messages for this XOP.
	}
	SetXOPResult(result);
}

static int RegisterOperations(void)		// Register any operations with Igor.
{
	int result;
	
	if (result = RegisterAnalyzePALMImages())
		return result;
	if (result = RegisterReadCCDImages())
		return result;
	if (result = RegisterProcessCCDImages())
		return result;
	if (result = RegisterAnalyzeCCDImages())
		return result;
	if (result = RegisterTestThreshold())
		return result;
	if (result = RegisterConvolveImages())
		return result;
	if (result = RegisterMakeBitmapPALMImage())
		return result;
	
	// There are no more operations added by this XOP.
	
	return 0;
}


/*	main(ioRecHandle)
 
 This is the initial entry point at which the host application calls XOP.
 The message sent by the host must be INIT.
 
 main does any necessary initialization and then sets the XOPEntry field of the
 ioRecHandle to the address to be called for future messages.
 */
HOST_IMPORT int main(IORecHandle ioRecHandle) {
	int result;
	
	XOPInit(ioRecHandle);							// Do standard XOP initialization.
	
	SetXOPEntry(XOPEntry);							// Set entry point for future calls.
	
	if (result = RegisterOperations()) {
		SetXOPResult(result);
	}
	else {
		SetXOPResult(0);
	}
}

class INCOMPATIBLE_WAVE_FORMAT {};


int convert_handle_to_string(Handle handle, string &output_path) {
	int err;
	char handle_char[1024];
	char handle_char_POSIX[1024];
	
	err = GetCStringFromHandle(handle, handle_char, 1023);
	if (err != 0) {
		return err;
	}
	
	#ifdef _MACINTOSH_
		err = WinToMacPath(handle_char);
		if (err != 0) {
			return err;
		}
		
		
		err = HFSToPosixPath(handle_char, handle_char_POSIX, 0);
		if (err != 0) {
			return err;
		}
		output_path.assign(handle_char_POSIX);
	#endif
	#ifdef _WINDOWS_
		err = MacToWinPath(handle_char);
		if (err != 0) {
			return err;
		}
		output_path.assign(handle_char);
	#endif
	
	return 0;
	
}



boost::shared_ptr<encap_gsl_matrix> copy_IgorDPWave_to_gsl_matrix(waveHndl wave) {
	// copy a Igor wave into a new gsl_matrix
	
	int err;
	long numDimensions; 
	long dimensionSizes[MAX_DIMENSIONS+1];
	size_t x_size, y_size;
	long indices[MAX_DIMENSIONS];
	double value[2];
	
	
	err = MDGetWaveDimensions(wave, &numDimensions, dimensionSizes);
	if (err != 0) {
		throw err;
	}
	if (numDimensions != 2) {
		throw INCOMPATIBLE_DIMENSIONING;
	}
	
	x_size = dimensionSizes[0];
	y_size = dimensionSizes[1];
	
	boost::shared_ptr<encap_gsl_matrix> matrix(new encap_gsl_matrix(x_size, y_size));
	
	for (size_t j = 0; j < y_size; ++j) {
		for (size_t i = 0; i < x_size; ++i) {
			indices[0] = i;
			indices[1] = j;
			
			err = MDGetNumericWavePointValue(wave, indices, value);
			if (err != 0) {
				throw err;
			}
			
			matrix->set(i, j, value[0]);
		}
	}
	
	return matrix;
}

waveHndl copy_gsl_matrix_to_IgorDPWave(boost::shared_ptr<encap_gsl_matrix> matrix, string waveName) {
	
	waveHndl DPWave;
	
	int err;
	long indices[MAX_DIMENSIONS];
	long dimensionSizes[MAX_DIMENSIONS+1];
	double value[2];
	
	// special case:
	// if the matrix is NULL (such as when there are no positions found)
	// then we return an empty wave
	if (matrix.get() == NULL) {
		dimensionSizes[0] = 0;
		dimensionSizes[1] = 0;
		dimensionSizes[2] = 0;
		
		err = MDMakeWave(&DPWave, waveName.c_str(), NULL, dimensionSizes, NT_FP64, 1);
		if (err != 0) {
			throw err;
		}
		
		return DPWave;
		
	}
		
		
	size_t x_size = (size_t)matrix->get_x_size();
	size_t y_size = (size_t)matrix->get_y_size();
	
	dimensionSizes[0] = x_size;
	dimensionSizes[1] = y_size;
	dimensionSizes[2] = 0;
	
	err = MDMakeWave(&DPWave, waveName.c_str(), NULL, dimensionSizes, NT_FP64, 1);
	if (err != 0) {
		throw err;
	}
	
	for (size_t j = 0; j < y_size; ++j) {
		for (size_t i = 0; i < x_size; ++i) {
			indices[0] = i;
			indices[1] = j;
			
			value[0] = matrix->get(i, j);
			
			err = MDSetNumericWavePointValue(DPWave, indices, value);
			if (err != 0) {
				throw err;
			}
		}
	}
	
	return DPWave;
}



boost::shared_ptr<ImageLoader> get_image_loader_for_camera_type(unsigned long camera_type, string data_file_path, unsigned long image_cache_size) {
	// image_cache_size has a default value of N_SIMULTANEOUS_IMAGE_LOADS
	
	boost::shared_ptr<ImageLoader> image_loader;
	
	switch (camera_type) {
		case 0:	// spe files
			image_loader = boost::shared_ptr<ImageLoader>(new ImageLoaderSPE(data_file_path, image_cache_size));
			break;
		case 1:
			image_loader = boost::shared_ptr<ImageLoader>(new ImageLoaderAndor(data_file_path, image_cache_size));
			break;
		case 2:
			image_loader = boost::shared_ptr<ImageLoader>(new ImageLoaderHamamatsu(data_file_path, image_cache_size));
			break;
		case 3:	// 3 is reserved for TIFF files
			image_loader = boost::shared_ptr<ImageLoader>(new ImageLoaderTIFF(data_file_path, image_cache_size));
			break;
		case 4:
			image_loader = boost::shared_ptr<ImageLoader>(new SimpleImageLoader(data_file_path, image_cache_size));
			break;
		case 5:	// Zeiss lsm files
			image_loader = boost::shared_ptr<ImageLoader>(new ImageLoaderTIFF(data_file_path, image_cache_size));
			break;
		case 6: // Matrix wave in Igor
			image_loader = boost::shared_ptr<ImageLoader>(new ImageLoaderIgor(data_file_path));
			break;
		default:
			throw UNSUPPORTED_CCD_FILE_TYPE;
			break;
	}
	
	return image_loader;
	
}


boost::shared_ptr<encap_gsl_volume> copy_IgorDPWave_to_gsl_volume(waveHndl wave) {
	int err;
	long indices[MAX_DIMENSIONS];
	long dimensionSizes[MAX_DIMENSIONS+1];
	long numDimensions;
	double value[2];
	size_t x_size, y_size, z_size;
	
	err = MDGetWaveDimensions(wave, &numDimensions, dimensionSizes);
	if (err != 0) {
		throw err;
	}
	if (numDimensions != 3) {
		throw INCOMPATIBLE_DIMENSIONING;
	}
	
	x_size = dimensionSizes[0];
	y_size = dimensionSizes[1];
	z_size = dimensionSizes[2];
	
	boost::shared_ptr<encap_gsl_volume> volume(new encap_gsl_volume(x_size, y_size, z_size));
	
	for (size_t k = 0; k < z_size; ++k)
		for (size_t j = 0; j < y_size; ++j) {
			for (size_t i = 0; i < x_size; ++i) {
				indices[0] = i;
				indices[1] = j;
				indices[2] = k;
				
				err = MDGetNumericWavePointValue(wave, indices, value);
				if (err != 0) {
					throw err;
				}
				
				volume->set(i, j, k, value[0]);
			}
		}
	
	return volume;
}

waveHndl copy_gsl_volume_to_IgorDPWave(boost::shared_ptr<encap_gsl_volume> volume, string waveName) {
	
	waveHndl DPWave;
	
	int err;
	long indices[MAX_DIMENSIONS];
	long dimensionSizes[MAX_DIMENSIONS+1];
	double value[2];
	
	// special case:
	// if the matrix is NULL (such as when there are no positions found)
	// then we return an empty wave
	if (volume.get() == NULL) {
		dimensionSizes[0] = 0;
		dimensionSizes[1] = 0;
		dimensionSizes[2] = 0;
		
		err = MDMakeWave(&DPWave, waveName.c_str(), NULL, dimensionSizes, NT_FP64, 1);
		if (err != 0) {
			throw err;
		}
		
		return DPWave;
		
	}
	
	
	size_t x_size = (size_t)volume->get_x_size();
	size_t y_size = (size_t)volume->get_y_size();
	size_t z_size = (size_t)volume->get_z_size();
	
	dimensionSizes[0] = x_size;
	dimensionSizes[1] = y_size;
	dimensionSizes[2] = z_size;
	dimensionSizes[3] = 0;
	
	err = MDMakeWave(&DPWave, waveName.c_str(), NULL, dimensionSizes, NT_FP64, 1);
	if (err != 0) {
		throw err;
	}
	
	for (size_t k = 0; k < z_size; ++k) {
		for (size_t j = 0; j < y_size; ++j) {
			for (size_t i = 0; i < x_size; ++i) {
				indices[0] = i;
				indices[1] = j;
				indices[2] = k;
				
				value[0] = volume->get(i, j, k);
				
				err = MDSetNumericWavePointValue(DPWave, indices, value);
				if (err != 0) {
					throw err;
				}
			}
		}
	}
	
	return DPWave;
}
	