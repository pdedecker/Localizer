/*
 *  PALM_analysis_IgorXOP.cpp
 *  PALM analysis
 *
 *  Created by Peter Dedecker on 05/01/2008.
 *  Copyright 2008 __MyCompanyName__. All rights reserved.
 *
 */

#include "PALM_analysis_IgorXOP.h"

// the framework below was generated by Igor

// Runtime param structure for AnalyzePALMImages operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct AnalyzePALMImagesRuntimeParams {
	// Flag parameters.
	
	// Parameters for /M flag group.
	int MFlagEncountered;
	double method;
	int MFlagParamsSet[1];
	
	// Parameters for /D flag group.
	int DFlagEncountered;
	double thresholding_method;
	int DFlagParamsSet[1];
	
	// Parameters for /Y flag group.
	int YFlagEncountered;
	double camera_type;
	int YFlagParamsSet[1];
	
	// Parameters for /G flag group.
	int GFlagEncountered;
	double preprocessing;
	double postprocessing;
	int GFlagParamsSet[2];
	
	// Parameters for /F flag group.
	int FFlagEncountered;
	double particle_finder;
	int FFlagParamsSet[1];
	
	// Parameters for /T flag group.
	int TFlagEncountered;
	double treshold_parameter;
	int TFlagParamsSet[1];
	
	// Parameters for /B flag group.
	int BFlagEncountered;
	double background;
	int BFlagParamsSet[1];
	
	// Parameters for /R flag group.
	int RFlagEncountered;
	double radius;
	int RFlagParamsSet[1];
	
	// Parameters for /W flag group.
	int WFlagEncountered;
	double initial_width;
	int WFlagParamsSet[1];
	
	// Parameters for /E flag group.
	int EFlagEncountered;
	double min_distance_from_edge;
	int EFlagParamsSet[1];
	
	// Parameters for /C flag group.
	int CFlagEncountered;
	double cutoff_radius;
	int CFlagParamsSet[1];
	
	// Parameters for /S flag group.
	int SFlagEncountered;
	double sigma;
	int SFlagParamsSet[1];
	
	// Parameters for /P flag group.
	int PFlagEncountered;
	waveHndl positions_wave;
	int PFlagParamsSet[1];
	
	// Parameters for /Q flag group.
	int QFlagEncountered;
	// There are no fields for this group because it has no parameters.
	
	// Parameters for /Z flag group.
	int ZFlagEncountered;
	// There are no fields for this group because it has no parameters.
	
	// Main parameters.
	
	// Parameters for simple main group #0.
	int name_of_output_waveEncountered;
	char name_of_output_wave[MAX_OBJ_NAME+1];
	int name_of_output_waveParamsSet[1];
	
	// Parameters for simple main group #1.
	int experiment_fileEncountered;
	Handle experiment_file;
	int experiment_fileParamsSet[1];
	
	// These are postamble fields that Igor sets.
	int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
	int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
};
typedef struct AnalyzePALMImagesRuntimeParams AnalyzePALMImagesRuntimeParams;
typedef struct AnalyzePALMImagesRuntimeParams* AnalyzePALMImagesRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.

// Runtime param structure for ReadCCDImages operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct ReadCCDImagesRuntimeParams {
	// Flag parameters.
	
	// Parameters for /Y flag group.
	int YFlagEncountered;
	double camera_type;
	int YFlagParamsSet[1];
	
	// Parameters for /H flag group.
	int HFlagEncountered;
	// There are no fields for this group because it has no parameters.
	
	// Parameters for /Z flag group.
	int ZFlagEncountered;
	// There are no fields for this group because it has no parameters.
	
	// Main parameters.
	
	// Parameters for simple main group #0.
	int start_imageEncountered;
	double start_image;
	int start_imageParamsSet[1];
	
	// Parameters for simple main group #1.
	int end_imageEncountered;
	double end_image;
	int end_imageParamsSet[1];
	
	// Parameters for simple main group #2.
	int experiment_fileEncountered;
	Handle experiment_file;
	int experiment_fileParamsSet[1];
	
	// These are postamble fields that Igor sets.
	int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
	int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
	struct tag_UserFuncThreadInfo *tp;		// If not null, we are running from a ThreadSafe function.
};
typedef struct ReadCCDImagesRuntimeParams ReadCCDImagesRuntimeParams;
typedef struct ReadCCDImagesRuntimeParams* ReadCCDImagesRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.

// Runtime param structure for ProcessCCDImages operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct ProcessCCDImagesRuntimeParams {
	// Flag parameters.
	
	// Parameters for /Y flag group.
	int YFlagEncountered;
	double camera_type;
	int YFlagParamsSet[1];
	
	// Parameters for /M flag group.
	int MFlagEncountered;
	double method;
	int MFlagParamsSet[1];
	
	// Parameters for /N flag group.
	int NFlagEncountered;
	double method_parameter;
	int NFlagParamsSet[1];
	
	// Parameters for /R flag group.
	int RFlagEncountered;
	double startX;
	double endX;
	double startY;
	double endY;
	int RFlagParamsSet[4];
	
	// Parameters for /OUT flag group.
	int OUTFlagEncountered;
	double outputType;
	int OUTFlagParamsSet[1];
	
	// Parameters for /O flag group.
	int OFlagEncountered;
	// There are no fields for this group because it has no parameters.
	
	// Main parameters.
	
	// Parameters for simple main group #0.
	int input_fileEncountered;
	Handle input_file;
	int input_fileParamsSet[1];
	
	// Parameters for simple main group #1.
	int output_fileEncountered;
	Handle output_file;
	int output_fileParamsSet[1];
	
	// These are postamble fields that Igor sets.
	int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
	int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
};
typedef struct ProcessCCDImagesRuntimeParams ProcessCCDImagesRuntimeParams;
typedef struct ProcessCCDImagesRuntimeParams* ProcessCCDImagesRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.

// Runtime param structure for AnalyzeCCDImages operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct AnalyzeCCDImagesRuntimeParams {
	// Flag parameters.
	
	// Parameters for /Y flag group.
	int YFlagEncountered;
	double camera_type;
	int YFlagParamsSet[1];
	
	// Parameters for /M flag group.
	int MFlagEncountered;
	double method;
	int MFlagParamsSet[1];
	
	// Parameters for /R flag group.
	int RFlagEncountered;
	double RFlagNumber0;
	double RFlagNumber1;
	double RFlagNumber2;
	double RFlagNumber3;
	int RFlagParamsSet[4];
	
	// Main parameters.
	
	// Parameters for simple main group #0.
	int output_waveEncountered;
	char output_wave[MAX_OBJ_NAME+1];
	int output_waveParamsSet[1];
	
	// Parameters for simple main group #1.
	int input_fileEncountered;
	Handle input_file;
	int input_fileParamsSet[1];
	
	// These are postamble fields that Igor sets.
	int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
	int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
};
typedef struct AnalyzeCCDImagesRuntimeParams AnalyzeCCDImagesRuntimeParams;
typedef struct AnalyzeCCDImagesRuntimeParams* AnalyzeCCDImagesRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.

// Runtime param structure for TestThreshold operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct TestThresholdRuntimeParams {
	// Flag parameters.
	
	// Parameters for /M flag group.
	int MFlagEncountered;
	double method;
	int MFlagParamsSet[1];
	
	// Parameters for /T flag group.
	int TFlagEncountered;
	double parameter;
	int TFlagParamsSet[1];
	
	// Parameters for /P flag group.
	int PFlagEncountered;
	double parameter2;
	int PFlagParamsSet[1];
	
	// Parameters for /G flag group.
	int GFlagEncountered;
	double preprocessing;
	double postprocessing;
	int GFlagParamsSet[2];
	
	// Parameters for /F flag group.
	int FFlagEncountered;
	double particle_finder;
	int FFlagParamsSet[1];
	
	// Parameters for /R flag group.
	int RFlagEncountered;
	double radiusBetweenParticles;
	int RFlagParamsSet[1];
	
	// Parameters for /S flag group.
	int SFlagEncountered;
	double output_located_particles;
	int SFlagParamsSet[1];
	
	// Main parameters.
	
	// Parameters for simple main group #0.
	int CCD_FrameEncountered;
	waveHndl CCD_Frame;
	int CCD_FrameParamsSet[1];
	
	// These are postamble fields that Igor sets.
	int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
	int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
};
typedef struct TestThresholdRuntimeParams TestThresholdRuntimeParams;
typedef struct TestThresholdRuntimeParams* TestThresholdRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.

// Runtime param structure for ConvolveImages operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct ConvolveImagesRuntimeParams {
	// Flag parameters.
	
	// Main parameters.
	
	// Parameters for simple main group #0.
	int firstImageEncountered;
	waveHndl firstImage;
	int firstImageParamsSet[1];
	
	// Parameters for simple main group #1.
	int secondImageEncountered;
	waveHndl secondImage;
	int secondImageParamsSet[1];
	
	// These are postamble fields that Igor sets.
	int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
	int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
};
typedef struct ConvolveImagesRuntimeParams ConvolveImagesRuntimeParams;
typedef struct ConvolveImagesRuntimeParams* ConvolveImagesRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.


// Runtime param structure for MakeBitmapPALMImage operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct MakeBitmapPALMImageRuntimeParams {
	// Flag parameters.
	
	// Parameters for /M flag group.
	int MFlagEncountered;
	double deviationMethod;
	int MFlagParamsSet[1];
	
	// Parameters for /S flag group.
	int SFlagEncountered;
	double scaleFactor;
	int SFlagParamsSet[1];
	
	// Parameters for /L flag group.
	int LFlagEncountered;
	double upperLimit;
	int LFlagParamsSet[1];
	
	// Parameters for /W flag group.
	int WFlagEncountered;
	double CCDXSize;
	double CCDYSize;
	double ImageWidth;
	double ImageHeight;
	int WFlagParamsSet[4];
	
	// Parameters for /WGHT flag group.
	int WGHTFlagEncountered;
	double emitterWeighing;
	int WGHTFlagParamsSet[1];
	
	// Parameters for /P flag group.
	int PFlagEncountered;
	double PSFWidth;
	int PFlagParamsSet[1];
	
	// Main parameters.
	
	// Parameters for simple main group #0.
	int positionsWaveEncountered;
	waveHndl positionsWave;
	int positionsWaveParamsSet[1];
	
	// These are postamble fields that Igor sets.
	int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
	int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
};
typedef struct MakeBitmapPALMImageRuntimeParams MakeBitmapPALMImageRuntimeParams;
typedef struct MakeBitmapPALMImageRuntimeParams* MakeBitmapPALMImageRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.

// Runtime param structure for RipleyLFunctionClustering operation.
#include "XOPStructureAlignmentTwoByte.h"	// All structures passed to Igor are two-byte aligned.
struct RipleyLFunctionClusteringRuntimeParams {
	// Flag parameters.
	
	// Parameters for /RNGE flag group.
	int RNGEFlagEncountered;
	double calculationRange;
	double nBins;
	int RNGEFlagParamsSet[2];
	
	// Parameters for /REGN flag group.
	int REGNFlagEncountered;
	double lowerX;
	double upperX;
	double lowerY;
	double upperY;
	int REGNFlagParamsSet[4];
	
	// Main parameters.
	
	// Parameters for simple main group #0.
	int positionsWaveEncountered;
	waveHndl positionsWave;
	int positionsWaveParamsSet[1];
	
	// These are postamble fields that Igor sets.
	int calledFromFunction;					// 1 if called from a user function, 0 otherwise.
	int calledFromMacro;					// 1 if called from a macro, 0 otherwise.
};
typedef struct RipleyLFunctionClusteringRuntimeParams RipleyLFunctionClusteringRuntimeParams;
typedef struct RipleyLFunctionClusteringRuntimeParams* RipleyLFunctionClusteringRuntimeParamsPtr;
#include "XOPStructureAlignmentReset.h"		// Reset structure alignment to default.


static int ExecuteAnalyzePALMImages(AnalyzePALMImagesRuntimeParamsPtr p) {
	gsl_set_error_handler_off();	// we will handle errors ourselves
	int err = 0;
	double threshold_parameter, radiusBetweenParticles, initial_width, min_distance_from_edge, cutoff_radius, sigma, background;
	std::string name_of_output_wave;
	std::string data_file_path;
	size_t camera_type;
	int method;
	int particle_finding_method;
	int fitting_positions_supplied_in_wave = 0;	// determines if we have to determine the positions to fit in ourselves, or if we can read them from the wave
	long numDimensions;
	long dimensionSizes[MAX_DIMENSIONS + 1];
	waveHndl fitting_positions = NULL;
	int quiet = 0;
	int returnErrors = 1;
	
	std::ostringstream analysisOptionsStream;	// a stringstream that is built up during the options parsing
												// and contains the settings that are used
												// it can be used to add metadata to the fitted positions
												// such as wave notes or file headers
												// the information is added in semicolon-separated key:value pairs
	
	size_t preprocessing_method;
	size_t thresholding_method;
	size_t postprocessing_method;
	
	boost::shared_ptr<ImageLoader> image_loader;
	boost::shared_ptr<FitPositions> positions_fitter;
	boost::shared_ptr<ThresholdImage> thresholder;
	boost::shared_ptr<ThresholdImage_Preprocessor> preprocessor;
	boost::shared_ptr<ThresholdImage_Postprocessor> postprocessor;
	boost::shared_ptr<ParticleFinder> particle_finder;
	boost::shared_ptr<PALMAnalysisController> analysisController;
	boost::shared_ptr<LocalizedPositionsContainer> localizedPositions;
	boost::shared_ptr<PALMAnalysisProgressReporter> progressReporter;
	
	// SOME STUFF THAT WE HAVE TO GET OUT OF THE WAY
	if (sizeof(char) != 1)
		return SIZE_OF_CHAR_IS_NOT_ONE_BYTE_DEF;
	if (sizeof(float) != 4)
		return SIZE_OF_FLOAT_IS_NOT_FOUR_BYTES_DEF;
	
	
	// Flag parameters.
	
	if (p->MFlagEncountered) {
		// Parameter: p->method
		
		// 0 means Gaussian fitting
		// 1 means multiplication method (Thompson, Biophys J 2002)
		method = (int)(p->method + 0.5);
		analysisOptionsStream << "LOCALIZATION METHOD:" << method << ';';
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->DFlagEncountered) {
		// Parameter: p->thresholding_method
		thresholding_method = (int)(p->thresholding_method + 0.5);
		analysisOptionsStream << "THRESHOLD METHOD:" << thresholding_method << ';';
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->YFlagEncountered) {
		// Parameter: p->camera_type
		camera_type = (size_t)(p->camera_type + 0.5);
		analysisOptionsStream << "THRESHOLD METHOD:" << camera_type << ';';
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->GFlagEncountered) {
		// Parameter: p->preprocessing
		// Parameter: p->postprocessing
		preprocessing_method = (size_t)(p->preprocessing + 0.5);
		postprocessing_method = (size_t)(p->postprocessing + 0.5);
	} else {
		// if this flag doesn't appear then we assume that we don't want any pre- or postprocessing
		preprocessing_method = 0;
		postprocessing_method = 0;
	}
	
	analysisOptionsStream << "PREPROCESSING:" << preprocessing_method << ';';
	analysisOptionsStream << "POSTPROCESSING:" << postprocessing_method << ';';
	
	if (p->FFlagEncountered) {
		// Parameter: p->particle_finder
		particle_finding_method = (int)(p->particle_finder + 0.5);
		analysisOptionsStream << "PARTICLE FINDING METHOD:" << particle_finding_method << ';';
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->TFlagEncountered) {
		// Parameter: p->treshold_parameter
		threshold_parameter = p->treshold_parameter;
		if (thresholding_method == 0)
			analysisOptionsStream << "PFA:" << threshold_parameter << ';';
		if (thresholding_method == 8)
			analysisOptionsStream << "ABSOLUTE THRESHOLD:" << threshold_parameter << ';';
			
	} else {
		if ((thresholding_method == 0) || (thresholding_method == 8)) {
			return TOO_FEW_PARAMETERS;
		}
	}
	
	if (p->BFlagEncountered) {
		// Parameter: p->background
		background = p->background;
		analysisOptionsStream << "BACKGROUND:" << background << ';';
	} else {
		background = 1000;
	}
	
	if (p->RFlagEncountered) {
		// Parameter: p->radius
		radiusBetweenParticles = p->radius;
		if (particle_finding_method == 2) {
			analysisOptionsStream << "MINIMUM DISTANCE BETWEEN PARTICLES:" << particle_finding_method << ';';
		}
	} else {
		if (particle_finding_method == 2) {
			return TOO_FEW_PARAMETERS;
		}
	}
	
	if (p->WFlagEncountered) {
		// Parameter: p->initial_width
		initial_width = p->initial_width;
	} else {
		initial_width = 2;
	}
	
	if (method != 2)
		analysisOptionsStream << "GAUSSIAN WIDTH:" << initial_width << ';';
	
	if (p->EFlagEncountered) {
		// Parameter: p->min_distance_from_edge
		min_distance_from_edge = p->min_distance_from_edge;
	} else {
		min_distance_from_edge = 11;
	}
	
	analysisOptionsStream << "MIN DISTANCE FROM EDGE:" << min_distance_from_edge << ';';
	
	if (p->CFlagEncountered) {
		// Parameter: p->cutoff_radius
		cutoff_radius = p->cutoff_radius;
	} else {
		cutoff_radius = 10;
	}
	
	analysisOptionsStream << "CUTOFF RADIUS:" << cutoff_radius << ';';
	
	if (p->SFlagEncountered) {
		// Parameter: p->sigma
		sigma = p->sigma;
	} else {
		sigma = 1;
	}
	
	if (p->PFlagEncountered) {
		// Parameter: p->positions_wave (test for NULL handle before using)
		if (p->positions_wave == NULL) {
			return NOWAV;
		}
		
		fitting_positions = p->positions_wave;
		
		if (WaveType(fitting_positions) != NT_FP64) {
			return NT_INCOMPATIBLE;
		}
		
		err = MDGetWaveDimensions(fitting_positions, &numDimensions, dimensionSizes);
		if (err != 0) {
			return err;
		}
		
		if ((numDimensions != 2) || (dimensionSizes[1] != 3)) {
			return INCOMPATIBLE_DIMENSIONING;
		}
		
		fitting_positions_supplied_in_wave = 1;
	} else {
		fitting_positions_supplied_in_wave = 0;
	}
	
	if (p->QFlagEncountered) {
		quiet = 1;
	} else {
		quiet = 0;
	}
	
	if (p->ZFlagEncountered) {
		returnErrors = 0;
	} else {
		returnErrors = 1;
	}
	
	// Main parameters.
	
	if (p->name_of_output_waveEncountered) {
		// Parameter: p->name_of_output_wave
		name_of_output_wave.assign(p->name_of_output_wave);
	} else {
		return EXPECTED_NAME;
	}
	
	try {
		
		if (p->experiment_fileEncountered) {
			// Parameter: p->experiment_file (test for NULL handle before using)
			if (p->experiment_file == NULL) {
				return EXPECTED_STRING_EXPR;
			}
			
			if (camera_type != CAMERA_TYPE_IGOR_WAVE) {
				err = ConvertHandleToFilepathString(p->experiment_file, data_file_path);
				if (err != 0) {
					return err;
				}
			} else {	// if we are loading data from an Igor wave then there is no need to convert
				err = ConvertHandleToString(p->experiment_file, data_file_path);
				if (err != 0) {
					return err;
				}
			}
			
			image_loader = get_image_loader_for_camera_type(camera_type, data_file_path);
			
			analysisOptionsStream << "ORIGINAL FILE PATH:" << data_file_path << ';';
			analysisOptionsStream << "CAMERA TYPE:" << camera_type << ';';
			analysisOptionsStream << "X SIZE:" << image_loader->getXSize() << ';';
			analysisOptionsStream << "Y SIZE:" << image_loader->getYSize() << ';';
			
		} else {	// file path parameter was not supplied from igor
			return EXPECTED_STRING_EXPR;
		}
		
		// which preprocessing do we wish to do?
		switch(preprocessing_method) {
			case PREPROCESSOR_NONE:	// no preprocessing
				//preprocessor = NULL;	// this is the default for a shared_ptr
				break;
			case PREPROCESSOR_3X3MEDIAN:	// 3x3 median filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MedianFilter(3,3));
				break;
			case PREPROCESSOR_5X5MEDIAN:	// 5x5 median filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MedianFilter(5,5));
				break;
			case PREPROCESSOR_1X1GAUSSIAN:	// 1x1 Gaussian filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_GaussianSmoothing(1));
				break;
			case PREPROCESSOR_2X2GAUSSIAN:	// 2x2 Gaussian filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_GaussianSmoothing(2));
				break;
			case PREPROCESSOR_3X3MEAN:	// 3x3 mean filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MeanFilter(3,3));
				break;
			case PREPROCESSOR_5X5MEAN:	// 5x5 mean filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MeanFilter(5,5));
				break;
			default:
				return UNKNOWN_THRESHOLD_PREPROCESSING_METHOD;
				break;
		}
		
		
		// choose which thresholding we want to do
		switch(thresholding_method) {
			case THRESHOLD_METHOD_GLRT:	// the GLRT test proposed by Arnauld et al in Nat Methods 5:687 2008
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_GLRT_FFT(threshold_parameter, initial_width));
				break;
			case THRESHOLD_METHOD_IGOR_ITERATIVE:	// Igor's iterative approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Iterative());
				break;
			case THRESHOLD_METHOD_IGOR_BIMODAL:	// Igor's iterative approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Bimodal());
				break;
			case THRESHOLD_METHOD_IGOR_ADAPTIVE:	// Igor's adaptive approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Adaptive());
				break;
			case THRESHOLD_METHOD_IGOR_FUZZY_1:	// Igor's first fuzzy approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Fuzzy1());
				break;
			case THRESHOLD_METHOD_IGOR_FUZZY_2:	// Igor's second fuzzy approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Fuzzy2());
				break;
			case THRESHOLD_METHOD_ISODATA:	// isodata algorithm (http://www.ph.tn.tudelft.nl/Courses/FIP/noframes/fip-Segmenta.html)
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Isodata());
				break;
			case THRESHOLD_METHOD_TRIANGLE:	// modified triangle algorithm (http://www.ph.tn.tudelft.nl/Courses/FIP/noframes/fip-Segmenta.html)
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Triangle());
				break;
			case THRESHOLD_METHOD_DIRECT:	// direct threshold
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Direct(threshold_parameter));
				break;
			default:
				return UNKNOWN_CCD_IMAGES_PROCESSING_METHOD;
				break;
		}
		
		// which postprocessing do we wish to do?
		switch(postprocessing_method) {
			case POSTPROCESSOR_NONE:	// no postprocessing
				//postprocessor = NULL;	// this is the default for a shared_ptr
				break;
			case POSTPROCESSOR_REMOVE_ISOLATED_PIXELS:	// remove isolated pixels
				postprocessor = boost::shared_ptr<ThresholdImage_Postprocessor>(new ThresholdImage_Postprocessor_RemoveIsolatedPixels());
				break;
			case POSTPROCESSOR_REJECT_PIXELS_BELOW_MEAN:	// reject 'on' pixels that have values below the intensity mean of the image
				postprocessor = boost::shared_ptr<ThresholdImage_Postprocessor>(new ThresholdImage_Postprocessor_RemovePixelsBelowMean());
				break;
			default:
				return UNKNOWN_THRESHOLD_POSTPROCESSING_METHOD;
				break;
		}
		
		// which particle finding method do we wish to use?
		switch (particle_finding_method) {
			case PARTICLEFINDER_ADJACENT4:
				particle_finder = boost::shared_ptr<ParticleFinder>(new ParticleFinder_adjacent4(min_distance_from_edge));
				break;
			case PARTICLEFINDER_ADJACENT8:
				particle_finder = boost::shared_ptr<ParticleFinder>(new ParticleFinder_adjacent8(min_distance_from_edge));
				break;
			case PARTICLEFINDER_RADIUS:	// traditional radius approach
				particle_finder = boost::shared_ptr<ParticleFinder>(new ParticleFinder_radius(min_distance_from_edge, radiusBetweenParticles));
				break;
			default:
				return UNKNOWN_CCD_IMAGES_PROCESSING_METHOD;
				break;
		}
		
		// which localization method do we wish to use?
		if (p->MFlagEncountered) {
			switch (method) {
				case LOCALIZATION_METHOD_2DGAUSS:
					positions_fitter = boost::shared_ptr<FitPositions>(new FitPositionsGaussian(cutoff_radius, initial_width, sigma));
					break;
				case LOCALIZATION_METHOD_2DGAUSS_FIXEDWIDTH:
					positions_fitter = boost::shared_ptr<FitPositions>(new FitPositionsGaussian_FixedWidth(cutoff_radius, initial_width, sigma));
					break;
				case LOCALIZATION_METHOD_MULTIPLICATION:
					positions_fitter = boost::shared_ptr<FitPositions>(new FitPositionsMultiplication(cutoff_radius, initial_width, sigma));
					break;
				case LOCALIZATION_METHOD_CENTROID:
					positions_fitter = boost::shared_ptr<FitPositions>(new FitPositionsCentroid(cutoff_radius));
					break;
				default:
					return UNKNOWN_CCD_IMAGES_PROCESSING_METHOD;
					break;
			}
			
		} else {
			positions_fitter = boost::shared_ptr<FitPositions>(new FitPositionsGaussian(cutoff_radius, initial_width, sigma));
		}
		
		if (quiet == 1) {
			progressReporter = boost::shared_ptr<PALMAnalysisProgressReporter> (new PALMAnalysisProgressReporter_Silent);
		} else {
			progressReporter = boost::shared_ptr<PALMAnalysisProgressReporter> (new PALMAnalysisProgressReporter_IgorCommandLine);
		}
		analysisController = boost::shared_ptr<PALMAnalysisController> (new PALMAnalysisController(thresholder, preprocessor, 
																								   postprocessor, particle_finder, positions_fitter,
																								   progressReporter));
		
		localizedPositions = analysisController->DoPALMAnalysis(image_loader);
		localizedPositions->writePositionsToWave(std::string("POS_out"), analysisOptionsStream.str());
	}
	catch (std::bad_alloc) {
		err = NOMEM;
	}
	catch (CANNOT_OPEN_FILE) {
		err = FILE_OPEN_ERROR;
	}
	catch (ERROR_READING_FILE_DATA e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		err = FILE_READ_ERROR;
	}
	catch (END_SHOULD_BE_LARGER_THAN_START) {
		err = END_SHOULD_BE_LARGER_THAN_START_DEF;
	}
	catch (std::range_error err) {
		XOPNotice(err.what());
		XOPNotice("\r");
	}
	catch (IMAGE_INDEX_BEYOND_N_IMAGES) {
		err = IMAGE_INDEX_BEYOND_N_IMAGES_DEF;
	}
	catch (USER_ABORTED e) {
		err = USER_ABORT;
	}
	catch (int e) {
		err = e;
	}
	catch (std::runtime_error e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		err = SYNERR;
	}
	catch (...) {
		return WM_UNKNOWN_ERROR;
	}
	
	SetOperationNumVar("V_flag", err);
	
	if ((err != 0) && (returnErrors != 0)) {
		return err;
	} else {
		return 0;
	}
}


static int ExecuteReadCCDImages(ReadCCDImagesRuntimeParamsPtr p) {
	gsl_set_error_handler_off();	// we will handle errors ourselves
	int err = 0;
	int returnErrors = 1;
	int camera_type;
	size_t start_image, end_image;
	std::string data_file_path;
	int header_only = 0;
	
	boost::shared_ptr<ImageLoader> image_loader;
	
	
	// SOME STUFF THAT WE HAVE TO GET OUT OF THE WAY
	if (sizeof(char) != 1)
		return SIZE_OF_CHAR_IS_NOT_ONE_BYTE_DEF;
	if (sizeof(float) != 4)
		return SIZE_OF_FLOAT_IS_NOT_FOUR_BYTES_DEF;
		
	
	// Flag parameters.
	
	if (p->YFlagEncountered) {
		// Parameter: p->camera_type
		camera_type = (int)(p->camera_type + 0.5);
		
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->HFlagEncountered) {
		header_only = 1;
	} else {
		header_only = 0;
	}
	
	if (p->ZFlagEncountered) {
		returnErrors = 0;
	} else {
		returnErrors = 1;
	}
	
	// Main parameters.
	
	if (p->start_imageEncountered) {
		// Parameter: p->start_image
		if (p->start_image < 0) {
			start_image = 0;
		} else {
		start_image = (size_t)(p->start_image + 0.5);
		}
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->end_imageEncountered) {
		// Parameter: p->end_image
		if (p->end_image < 0) {
			return EXPECT_POS_NUM;
		}
		end_image = (size_t)(p->end_image + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->experiment_fileEncountered) {
		// Parameter: p->experiment_file (test for NULL handle before using)
		if (p->experiment_file == NULL) {
			return EXPECTED_STRING_EXPR;
		}
		
		if (camera_type != CAMERA_TYPE_IGOR_WAVE) {
			err = ConvertHandleToFilepathString(p->experiment_file, data_file_path);
			if (err != 0) {
				return err;
			}
		} else {	// if we are loading data from an Igor wave then there is no need to convert
			err = ConvertHandleToString(p->experiment_file, data_file_path);
			if (err != 0) {
				return err;
			}
		}
		
		
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	try {
		
		// if we are here then everything should be okay
		image_loader = get_image_loader_for_camera_type(camera_type, data_file_path);
		
		if (header_only == 0) {
			err = load_partial_ccd_image(image_loader.get(), start_image, end_image);
		} else {
			err = parse_ccd_headers(image_loader.get());
		}
		
	}
	catch (std::bad_alloc) {
		err = NOMEM;
	}
	catch (CANNOT_OPEN_FILE) {
		err =  FILE_OPEN_ERROR;
	}
	catch (ERROR_READING_FILE_DATA e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		err =  FILE_READ_ERROR;
	}
	catch (END_SHOULD_BE_LARGER_THAN_START) {
		err =  END_SHOULD_BE_LARGER_THAN_START_DEF;
	}
	catch (std::range_error error) {
		XOPNotice(error.what());
		XOPNotice("\r");
		err =  INDEX_OUT_OF_RANGE;
	}
	catch (int e) {
		err =  e;
	}
	catch (IMAGE_INDEX_BEYOND_N_IMAGES) {
		err =  IMAGE_INDEX_BEYOND_N_IMAGES_DEF;
	}
	catch (std::runtime_error e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		err = SYNERR;
	}
	catch (...) {
		return WM_UNKNOWN_ERROR;
	}
	
	SetOperationNumVar("V_flag", err);
	
	if ((err != 0) && (returnErrors != 0)) {
		return err;
	} else {
		return 0;
	}
}


static int ExecuteProcessCCDImages(ProcessCCDImagesRuntimeParamsPtr p) {
	gsl_set_error_handler_off();	// we will handle errors ourselves
	int err = 0;
	int camera_type;
	int method;
	int overwrite = 0;	// if non-zero then we overwrite the output file if it exists
	int outputType;
	size_t startX, endX, startY, endY;
	
	double n_parameter;	// the value that corresponds to the /N flag
	
	std::string input_file_path;
	std::string output_file_path;
	
	boost::shared_ptr<ImageLoader> image_loader;
	boost::shared_ptr<ImageOutputWriter> output_writer;
	boost::shared_ptr<CCDImagesProcessor> ccd_image_processor;
	
	// SOME STUFF THAT WE HAVE TO GET OUT OF THE WAY
	if (sizeof(char) != 1)
		return SIZE_OF_CHAR_IS_NOT_ONE_BYTE_DEF;
	if (sizeof(float) != 4)
		return SIZE_OF_FLOAT_IS_NOT_FOUR_BYTES_DEF;
	
	
	
	// Flag parameters.
	
	if (p->YFlagEncountered) {
		// Parameter: p->camera_type
		camera_type = (int)(p->camera_type + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->MFlagEncountered) {
		// Parameter: p->method
		if (p-> method < 0) {
			return EXPECT_POS_NUM;
		}
		method = (int)(p->method + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->NFlagEncountered) {
		// Parameter: p->method_parameter
		if ((method == 0) && (p->method_parameter < 0)) {
			return EXPECT_POS_NUM;
		}
		n_parameter = p->method_parameter;
		
	} else {	// we didn't encounter the /N flag
				// for now this isn't a problem, but if we implement a method
				// that requires a parameter then we have to return an error here
		
		if (method == 0)	// subtract an average
			n_parameter = 0;	// if we don't specify /N then we want to subtract an average for the entire trace
		
	}
	
	if (p->OUTFlagEncountered) {
		// Parameter: p->outputType
		outputType = (int)(p->outputType + 0.5);
	} else {
		outputType = IMAGE_OUTPUT_TYPE_TIFF;
	}
	
	if (p->OFlagEncountered) {
		overwrite = 1;
	}
	
	if (p->RFlagEncountered) {
		// Parameter: p->startX
		// Parameter: p->endX
		// Parameter: p->startY
		// Parameter: p->endY
		
		// check that they are all positive
		if ((p->startX < 0) || (p->endX < 0) || (p->startY < 0) || (p->endY < 0)) {
			return EXPECT_POS_NUM;
		}
		if ((p->startX >= p->endX) || (p->startY >= p->endY)) {
			return EXPECT_POS_NUM;	// update this with the proper error message
		}
		
		startX = (size_t)(p->startX + 0.5);
		endX = (size_t)(p->endX + 0.5);
		startY = (size_t)(p->startY + 0.5);
		endY = (size_t)(p->endY + 0.5);
	} else {
		if (method == 4) {	// export a cropped version
			return TOO_FEW_PARAMETERS;
		}
	}
	
	// Main parameters.
	
	if (p->input_fileEncountered) {
		// Parameter: p->input_file (test for NULL handle before using)
		if (p->input_file == NULL) {
			return EXPECTED_STRING_EXPR;
		}
		if (camera_type != CAMERA_TYPE_IGOR_WAVE) {
			err = ConvertHandleToFilepathString(p->input_file, input_file_path);
			if (err != 0) {
				return err;
			}
		} else {	// if we are loading data from an Igor wave then there is no need to convert
			err = ConvertHandleToString(p->input_file, input_file_path);
			if (err != 0) {
				return err;
			}
		}
	} else {
		return EXPECTED_STRING_EXPR;
	}
	
	if (p->output_fileEncountered) {
		// Parameter: p->output_file (test for NULL handle before using)
		if (p->output_file == NULL) {
			return EXPECTED_STRING_EXPR;
		}
		if (outputType == IMAGE_OUTPUT_TYPE_IGOR) {
			err = ConvertHandleToString(p->output_file, output_file_path);
		} else {
			err = ConvertHandleToFilepathString(p->output_file, output_file_path);
		}
		if (err != 0) {
			return err;
		}
	} else {
		return EXPECTED_STRING_EXPR;
	}
	
	
	try {
		image_loader = get_image_loader_for_camera_type(camera_type, input_file_path);
		
		switch (outputType) {
			case IMAGE_OUTPUT_TYPE_TIFF:
				output_writer = boost::shared_ptr<ImageOutputWriter>(new TIFFImageOutputWriter(output_file_path, overwrite, COMPRESSION_NONE, image_loader->getStorageType()));
				break;
			case IMAGE_OUTPUT_TYPE_COMPRESSED_TIFF:
				output_writer = boost::shared_ptr<ImageOutputWriter>(new TIFFImageOutputWriter(output_file_path, overwrite, COMPRESSION_DEFLATE, image_loader->getStorageType()));
				break;
			case IMAGE_OUTPUT_TYPE_IGOR:
				output_writer = boost::shared_ptr<ImageOutputWriter>(new IgorImageOutputWriter(output_file_path, image_loader->get_total_number_of_images(), 
																							   overwrite));
				break;
			default:
				XOPNotice("Unknown output format (/OUT flag)\r");
				return UNSUPPORTED_CCD_FILE_TYPE;
		}
		
		// do the actual procedure
		switch (method) {
			case 0:		// subtract an average from the trace
				ccd_image_processor = boost::shared_ptr<CCDImagesProcessor>(new CCDImagesProcessorAverageSubtraction(image_loader.get(), output_writer.get(), 0));
				break;
			case 1:		// generate a difference image
				ccd_image_processor = boost::shared_ptr<CCDImagesProcessor>(new CCDImagesProcessorDifferenceImage(image_loader.get(), output_writer.get()));
				break;
			case 2:		// convert to a different form (determined by the output writer)
				ccd_image_processor = boost::shared_ptr<CCDImagesProcessor>(new CCDImagesProcessorConvertToSimpleFileFormat(image_loader.get(), output_writer.get()));
				break;
			case 3:		// output a cropped version of the image
				ccd_image_processor = boost::shared_ptr<CCDImagesProcessor>(new CCDImagesProcessorCrop(image_loader.get(), output_writer.get(), startX, endX, startY, endY));
				break;
			default:
				return UNKNOWN_CCD_IMAGES_PROCESSING_METHOD;
				break;
		}
		
		ccd_image_processor->convert_images();
	}
	
	catch (std::bad_alloc) {
		SetOperationNumVar("V_flag", NOMEM);
		return NOMEM;
	}
	catch (CANNOT_OPEN_FILE) {
		SetOperationNumVar("V_flag", FILE_OPEN_ERROR);
		return FILE_OPEN_ERROR;
	}
	catch (ERROR_READING_FILE_DATA e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		SetOperationNumVar("V_flag", FILE_READ_ERROR);
		return FILE_READ_ERROR;
	}
	catch (ERROR_WRITING_FILE_DATA e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		SetOperationNumVar("V_flag", FILE_WRITE_ERROR);
		return FILE_WRITE_ERROR;
	}
	catch (END_SHOULD_BE_LARGER_THAN_START) {
		SetOperationNumVar("V_flag", END_SHOULD_BE_LARGER_THAN_START_DEF);
		return END_SHOULD_BE_LARGER_THAN_START_DEF;
	}
	catch (std::range_error err) {
		SetOperationNumVar("V_flag", INDEX_OUT_OF_RANGE);
		XOPNotice(err.what());
		XOPNotice("\r");
		return INDEX_OUT_OF_RANGE;
	}
	catch (IMAGE_INDEX_BEYOND_N_IMAGES) {
		SetOperationNumVar("V_flag", IMAGE_INDEX_BEYOND_N_IMAGES_DEF);
		return IMAGE_INDEX_BEYOND_N_IMAGES_DEF;
	}
	catch (int e) {
		SetOperationNumVar("V_flag", e);
		return e;
	}
	catch (std::runtime_error e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		return SYNERR;
	}
	catch (...) {
		return WM_UNKNOWN_ERROR;
	}
	
	SetOperationNumVar("V_flag", 0.0);
	return err;
}


static int ExecuteAnalyzeCCDImages(AnalyzeCCDImagesRuntimeParamsPtr p) {
	gsl_set_error_handler_off();	// we will handle errors ourselves
	int err = 0;
	int camera_type;
	int method;
	
	long startX, startY, endX, endY, swap;
	
	std::string input_file_path;
	std::string name_of_output_wave;
	
	boost::shared_ptr<ImageLoader> image_loader;
	
	// Flag parameters.
	
	if (p->YFlagEncountered) {
		// Parameter: p->camera_type
		camera_type = (int)(p->camera_type + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
		
	
	if (p->MFlagEncountered) {
		// Parameter: p->method
		method = (int)(p->method + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->RFlagEncountered) {
		// Parameter: p->RFlagNumber0
		// Parameter: p->RFlagNumber0
		// Parameter: p->RFlagNumber0
		// Parameter: p->RFlagNumber0
		
		// check that they are all positive
		if ((p->RFlagNumber0 < 0) || (p->RFlagNumber1 < 0) || (p->RFlagNumber2 < 0) || (p->RFlagNumber3 < 0)) {
			return EXPECT_POS_NUM;
		}
		if ((p->RFlagNumber0 >= p->RFlagNumber1) || (p->RFlagNumber2 >= p->RFlagNumber3)) {
			return EXPECT_POS_NUM;	// update this with the proper error message
		}
		
		startX = (long)(p->RFlagNumber0 + 0.5);
		endX = (long)(p->RFlagNumber1 + 0.5);
		startY = (long)(p->RFlagNumber2 + 0.5);
		endY = (long)(p->RFlagNumber3 + 0.5);
		
		if (startX < 0)
			startX = 0;
		if (startY < 0)
			startY = 0;
		if (startX > endX) {
			swap = endX;
			endX = startX;
			startX = swap;
		}
		if (startY > endY) {
			swap = endY;
			endY = startY;
			startY = swap;
		}
			
		
		
	} else {
		startX = endX = startY = endY = -1;	// by convention '-1' means that we take the whole image
	}
	
	// Main parameters.
	
	if (p->output_waveEncountered) {
		// Parameter: p->output_wave
		name_of_output_wave.assign(p->output_wave);
	} else {
		return EXPECTED_NAME;
	}
	
	if (p->input_fileEncountered) {
		// Parameter: p->input_file (test for NULL handle before using)
		if (p->input_fileEncountered == 0) {
			return EXPECTED_STRING_EXPR;
		}
		if (camera_type != CAMERA_TYPE_IGOR_WAVE) {
			err = ConvertHandleToFilepathString(p->input_file, input_file_path);
			if (err != 0) {
				return err;
			}
		} else {	// if we are loading data from an Igor wave then there is no need to convert
			err = ConvertHandleToString(p->input_file, input_file_path);
			if (err != 0) {
				return err;
			}
		}
		
	} else {
		return EXPECTED_STRING_EXPR;
	}
	
	try {
		image_loader = get_image_loader_for_camera_type(camera_type, input_file_path);
	
		switch (method) {
			case 0:
				err = construct_summed_intensity_trace(image_loader.get(), name_of_output_wave, startX, startY, endX, endY);
				break;
			case 1:
				err = construct_average_image(image_loader.get(), name_of_output_wave, startX, startY, endX, endY);
				break;
			case 2:
				calculateStandardDeviationImage(image_loader.get(), name_of_output_wave, startX, startY, endX, endY);
				break;
			default:
				return UNKNOWN_CCD_IMAGES_ANALYSIS_METHOD;
		}
	}
	catch (std::bad_alloc) {
		return NOMEM;
	}
	catch (CANNOT_OPEN_FILE) {
		return FILE_OPEN_ERROR;
	}
	catch (ERROR_READING_FILE_DATA e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		return FILE_READ_ERROR;
	}
	catch (END_SHOULD_BE_LARGER_THAN_START) {
		return END_SHOULD_BE_LARGER_THAN_START_DEF;
	}
	catch (std::range_error err) {
		XOPNotice(err.what());
		XOPNotice("\r");
		return INDEX_OUT_OF_RANGE;
	}
	catch (IMAGE_INDEX_BEYOND_N_IMAGES) {
		return IMAGE_INDEX_BEYOND_N_IMAGES_DEF;
	}
	catch (int e) {
		return e;
	}
	catch (std::runtime_error e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		return SYNERR;
	}
	catch (...) {
		return WM_UNKNOWN_ERROR;
	}

	return 0;
}


static int ExecuteTestThreshold(TestThresholdRuntimeParamsPtr p) {
	gsl_set_error_handler_off();	// we will handle errors ourselves
	int err = 0;
	size_t method;
	size_t preprocessing_method, postprocessing_method;
	size_t particle_finding_method;
	int output_located_particles;
	double parameter, parameter2;
	double radiusBetweenParticles;
	waveHndl CCD_Frame_wave;
	waveHndl threshold_image_wave;
	boost::shared_ptr<PALMMatrix<double> > CCD_Frame;
	boost::shared_ptr<std::vector<position> > located_particles;
	
	// long numDimensions; 
	long dimensionSizes[MAX_DIMENSIONS+1];
	long x_size, y_size;
	long indices[MAX_DIMENSIONS];
	double value[2];
	
	
	boost::shared_ptr<PALMMatrix <unsigned char> > thresholded_image;
	
	
	boost::shared_ptr<ThresholdImage> thresholder;
	boost::shared_ptr<ThresholdImage_Preprocessor> preprocessor;
	boost::shared_ptr<ThresholdImage_Postprocessor> postprocessor;
	boost::shared_ptr<ParticleFinder> particlefinder;
	
	
	// Flag parameters.
	
	if (p->MFlagEncountered) {
		// Parameter: p->method
		method = (size_t)(p->method + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->TFlagEncountered) {
		// Parameter: p->parameter
		parameter = p->parameter;
	} else {
		if ((method == 0) || (method == 8)) {
			return TOO_FEW_PARAMETERS;
		}
	}
	
	if (p->PFlagEncountered) {
		// Parameter: p->parameter2
		parameter2 = p->parameter2;
	} else {
		if (method == 0) {
			return TOO_FEW_PARAMETERS;
		}
	}
	
	if (p->GFlagEncountered) {
		// Parameter: p->preprocessing
		// Parameter: p->postprocessing
		preprocessing_method = (size_t)(p->preprocessing + 0.5);
		postprocessing_method = (size_t)(p->postprocessing + 0.5);
	} else {
		// if this flag doesn't appear then we assume that we don't want any pre- or postprocessing
		preprocessing_method = 0;
		postprocessing_method = 0;
	}
	
	if (p->SFlagEncountered) {
		// Parameter: p->output_located_particles
		output_located_particles = (int)(p->output_located_particles + 0.5);
	} else {
		output_located_particles = 0;
	}
	
	if (p->FFlagEncountered) {	// choose which particle finder we want to use
		// Parameter: p->particle_finder
		particle_finding_method = (size_t)(p->particle_finder + 0.5);
	} else {
		if (output_located_particles == 1)
			return TOO_FEW_PARAMETERS;
	}
	
	if (p->RFlagEncountered) {
		// Parameter: p->radiusBetweenParticles
		radiusBetweenParticles = p->radiusBetweenParticles;
		if ((radiusBetweenParticles <= 0) && (particle_finding_method = 0)) {
			return EXPECT_POS_NUM;
		}
	} else {
		if (particle_finding_method == PARTICLEFINDER_RADIUS) {
			return TOO_FEW_PARAMETERS;
		}
	}
			
		
	
	// Main parameters.
	
	if (p->CCD_FrameEncountered) {
		// Parameter: p->CCD_Frame (test for NULL handle before using)
		if (p->CCD_Frame == NULL) {
			return NOWAV;
		} else {
			CCD_Frame_wave = p->CCD_Frame;
		}
	} else {
		return NOWAV;
	}
	
	try {
		
		// copy the Igor wave with the CCD Frame into a new gsl_matrix
		CCD_Frame = copy_IgorDPWave_to_gsl_matrix(CCD_Frame_wave);
		
		x_size = CCD_Frame->getXSize();
		y_size = CCD_Frame->getYSize();
		
		// which preprocessing do we wish to do?
		switch(preprocessing_method) {
			case 0:	// no preprocessing
				// preprocessor = NULL;	// this is the default for a smart pointer
				break;
			case 1:	// 3x3 median filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MedianFilter(3,3));
				break;
			case 2:	// 5x5 median filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MedianFilter(5,5));
				break;
			case 3:	// 1x1 Gaussian filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_GaussianSmoothing(1));
				break;
			case 4:	// 2x2 Gaussian filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_GaussianSmoothing(2));
				break;
			case 5:	// 3x3 mean filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MeanFilter(3,3));
				break;
			case 6:	// 5x5 mean filter
				preprocessor = boost::shared_ptr<ThresholdImage_Preprocessor>(new ThresholdImage_Preprocessor_MeanFilter(5,5));
				break;
			default:
				return UNKNOWN_THRESHOLD_PREPROCESSING_METHOD;
				break;
		}
		switch(method) {
			case 0:	// the GLRT test proposed by Arnauld et al in Nat Methods 5:687 2008
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_GLRT_FFT(parameter, parameter2));
				break;
			case 1:	// Igor's iterative approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Iterative());
				break;
			case 2:	// Igor's iterative approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Bimodal());
				break;
			case 3:	// Igor's adaptive approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Adaptive());
				break;
			case 4:	// Igor's first fuzzy approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Fuzzy1());
				break;
			case 5:	// Igor's second fuzzy approach
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Igor_Fuzzy2());
				break;
			case 6:	// isodata algorithm (http://www.ph.tn.tudelft.nl/Courses/FIP/noframes/fip-Segmenta.html)
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Isodata());
				break;
			case 7:	// modified triangle algorithm (http://www.ph.tn.tudelft.nl/Courses/FIP/noframes/fip-Segmenta.html)
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Triangle());
				break;
			case 8:	// direct threshold
				thresholder = boost::shared_ptr<ThresholdImage>(new ThresholdImage_Direct(parameter));
				break;
			default:
				return UNKNOWN_CCD_IMAGES_PROCESSING_METHOD;
				break;
		}
		
		
		// which postprocessing do we wish to do?
		switch(postprocessing_method) {
			case 0:	// no postprocessing
				//postprocessor = NULL;	// this is the default for a shared_ptr
				break;
			case 1:	// remove isolated pixels
				postprocessor = boost::shared_ptr<ThresholdImage_Postprocessor>(new ThresholdImage_Postprocessor_RemoveIsolatedPixels());
				break;
			case 2:	// reject 'on' pixels that have values below the intensity mean of the image
				postprocessor = boost::shared_ptr<ThresholdImage_Postprocessor>(new ThresholdImage_Postprocessor_RemovePixelsBelowMean());
				break;
			default:
				return UNKNOWN_THRESHOLD_POSTPROCESSING_METHOD;
				break;
		}
		
		// do we wish to show the located particle positions?
		// which method do we want to use?
		if (output_located_particles == 1) {
			switch (particle_finding_method) {
				case 0:
					particlefinder = boost::shared_ptr<ParticleFinder>(new ParticleFinder_adjacent4(10));
					break;
				case 1:
					particlefinder = boost::shared_ptr<ParticleFinder>(new ParticleFinder_adjacent8(10));
					break;
				case 2:	// traditional radius approach
					particlefinder = boost::shared_ptr<ParticleFinder>(new ParticleFinder_radius(10, radiusBetweenParticles));
					break;
				default:
					return UNKNOWN_CCD_IMAGES_PROCESSING_METHOD;
					break;
			}
		}
		
		
		
		// calculate the threshold
		thresholded_image = do_processing_and_thresholding(CCD_Frame, preprocessor, thresholder, postprocessor);
		
		// now create the output wave
		dimensionSizes[0] = x_size;
		dimensionSizes[1] = y_size;
		dimensionSizes[2] = 0;
		
		threshold_image_wave = MakeWaveUsingFullPath(std::string("M_ImageThresh"), dimensionSizes, NT_I8 | NT_UNSIGNED, 1);
		
		for (long j = 0; j < y_size; j++) {
			for (long i = 0; i < x_size; i++) {
				indices[0] = i;
				indices[1] = j;
				
				value[0] = (double)((*thresholded_image)(i, j));
				
				err = MDSetNumericWavePointValue(threshold_image_wave, indices, value);
				if (err != 0) {
					return err;
				}
			}
		}
		
		// if it is requested then output the positions
		if (output_located_particles == 1) {
			located_particles = particlefinder->findPositions(CCD_Frame, thresholded_image);
			
			long dimensionSizes[MAX_DIMENSIONS+1];
			long indices[MAX_DIMENSIONS];
			waveHndl outputWave;
			size_t nParticles = (*located_particles).size();
			dimensionSizes[0] = nParticles;
			dimensionSizes[1] = 4;	// warning: magic number
			dimensionSizes[2] = 0;
			double value[2];
			
			outputWave = MakeWaveUsingFullPath(std::string("M_locatedParticles"), dimensionSizes, NT_FP64, 1);
			
			for (size_t i = 0; i < nParticles; ++i) {
				indices[0] = i;
				indices[1] = 0;
				value[0] = (*located_particles)[i].get_intensity();
				MDSetNumericWavePointValue(outputWave, indices, value);
				indices[1] = 1;
				value[0] = (*located_particles)[i].get_x();
				MDSetNumericWavePointValue(outputWave, indices, value);
				indices[1] = 2;
				value[0] = (*located_particles)[i].get_y();
				MDSetNumericWavePointValue(outputWave, indices, value);
				indices[1] = 3;
				value[0] = (*located_particles)[i].get_background();
				MDSetNumericWavePointValue(outputWave, indices, value);
			}
		}
		
	}
	
	catch (std::bad_alloc) {
		return NOMEM;
	}
	catch (CANNOT_OPEN_FILE) {
		return FILE_OPEN_ERROR;
	}
	catch (ERROR_READING_FILE_DATA e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		return FILE_READ_ERROR;
	}
	catch (END_SHOULD_BE_LARGER_THAN_START) {
		return END_SHOULD_BE_LARGER_THAN_START_DEF;
	}
	catch (std::range_error err) {
		XOPNotice(err.what());
		XOPNotice("\r");
		return INDEX_OUT_OF_RANGE;
	}
	catch (int e) {
		return e;
	}
	catch (std::runtime_error e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		return SYNERR;
	}
	catch (...) {
		return WM_UNKNOWN_ERROR;
	}
	
	return err;
}


static int ExecuteConvolveImages(ConvolveImagesRuntimeParamsPtr p) {
	gsl_set_error_handler_off();	// we will handle errors ourselves
	int err = 0;
	boost::shared_ptr<PALMMatrix<double> > firstImage;
	boost::shared_ptr<PALMMatrix<double> > secondImage;
	boost::shared_ptr<PALMMatrix<double> > outputImage;
	waveHndl firstWave;
	waveHndl secondWave;
	waveHndl outputWave;
	
	// Main parameters.
	
	if (p->firstImageEncountered) {
		// Parameter: p->firstImage (test for NULL handle before using)
		if (p->firstImage == NULL) {
			return NOWAV;
		}
		firstWave = p->firstImage;
	} else {
		return NOWAV;
	}
	
	if (p->secondImageEncountered) {
		// Parameter: p->secondImage (test for NULL handle before using)
		if (p->firstImage == NULL) {
			return NOWAV;
		}
		secondWave = p->secondImage;
	} else {
		return NOWAV;
	}
	
	try {
		firstImage = copy_IgorDPWave_to_gsl_matrix(firstWave);
		secondImage = copy_IgorDPWave_to_gsl_matrix(secondWave);
		ConvolveMatricesWithFFTClass matrixConvolver;
		
		outputImage = matrixConvolver.ConvolveMatricesWithFFT(firstImage,secondImage);
		
		outputWave = copy_PALMMatrix_to_IgorDPWave(outputImage, "M_Convolved");
		
	}
	catch (std::bad_alloc) {
		return NOMEM;
	}
	catch (CANNOT_OPEN_FILE) {
		return FILE_OPEN_ERROR;
	}
	catch (ERROR_READING_FILE_DATA e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		return FILE_READ_ERROR;
	}
	catch (END_SHOULD_BE_LARGER_THAN_START) {
		return END_SHOULD_BE_LARGER_THAN_START_DEF;
	}
	catch (std::range_error err) {
		XOPNotice(err.what());
		XOPNotice("\r");
		return INDEX_OUT_OF_RANGE;
	}
	catch (int e) {
		return e;
	}
	catch (std::runtime_error e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		return SYNERR;
	}
	catch (...) {
		return WM_UNKNOWN_ERROR;
	}
	
	return err;
}


static int ExecuteMakeBitmapPALMImage(MakeBitmapPALMImageRuntimeParamsPtr p) {
	gsl_set_error_handler_off();	// we will handle errors ourselves
	int err = 0;
	int method, emitterWeighing;
	double scaleFactor, upperLimit, PSFWidth;
	size_t imageWidth, imageHeight, xSize, ySize;
	
	waveHndl positionsWave;
	
	boost::shared_ptr<PALMBitmapImageCalculator> imageCalculator;
	boost::shared_ptr<PALMBitmapImageDeviationCalculator> deviationCalculator;
	boost::shared_ptr<PALMAnalysisProgressReporter> progressReporter;
	boost::shared_ptr<PALMMatrix <double> > image;
	
	// Flag parameters.
	
	if (p->MFlagEncountered) {
		// Parameter: p->deviationMethod
		if (p->deviationMethod < 0) {
			return EXPECT_POS_NUM;
		}
		
		method = (int)(p->deviationMethod + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->SFlagEncountered) {
		// Parameter: p->scaleFactor
		if (p->scaleFactor <= 0)
			return EXPECT_POS_NUM;
		scaleFactor = p->scaleFactor;
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->LFlagEncountered) {
		// Parameter: p->upperLimit
		if (p->upperLimit <= 0)
			return EXPECT_POS_NUM;
		upperLimit = p->upperLimit;
	} else {
		if (method == 1) {	// calculate the width using the uncertainty from the fits
			return TOO_FEW_PARAMETERS;
		}
	}
	
	if (p->WFlagEncountered) {
		// Parameter: p->CCDXSize
		// Parameter: p->CCDYSize
		// Parameter: p->ImageWidth
		// Parameter: p->ImageHeight
		if ((p->CCDXSize <= 0) || (p->CCDYSize <= 0) || (p->ImageWidth <= 0) || (p->ImageHeight <= 0))
			return EXPECT_POS_NUM;
		xSize = (size_t)(p->CCDXSize + 0.5);
		ySize = (size_t)(p->CCDYSize + 0.5);
		imageWidth = (size_t)(p->ImageWidth + 0.5);
		imageHeight = (size_t)(p->ImageHeight + 0.5);
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->WGHTFlagEncountered) {
		// Parameter: p->emitterWeighing
		emitterWeighing = int(p->emitterWeighing + 0.5);
		if ((emitterWeighing != 0) && (emitterWeighing != 1)) {
			return EXPECT_POS_NUM;
		}
	} else {
		return TOO_FEW_PARAMETERS;
	}
	
	if (p->PFlagEncountered) {
		// Parameter: p->PSFWidth
		if (p->PSFWidth <= 0) {
			return EXPECT_POS_NUM;
		}
		
		PSFWidth = p->PSFWidth;
		
	} else {
		if (method == 2) {
			return TOO_FEW_PARAMETERS;
		}
	}
	
	// Main parameters.	
	if (p->positionsWaveEncountered) {
		// Parameter: p->positionsWave (test for NULL handle before using)
		if (p->positionsWave == NULL) {
			return NOWAV;
		}
		positionsWave = p->positionsWave;
	} else {
		return NOWAV;
	}
	
	
	// get the object that will calculate the standard deviation
	switch (method) {
		case 0:
			deviationCalculator = boost::shared_ptr<PALMBitmapImageDeviationCalculator> (new PALMBitmapImageDeviationCalculator_Constant(scaleFactor));
			break;
		case 1:
			deviationCalculator = boost::shared_ptr<PALMBitmapImageDeviationCalculator> (new PALMBitmapImageDeviationCalculator_FitUncertainty(scaleFactor, upperLimit));
			break;
		case 2:
			deviationCalculator = boost::shared_ptr<PALMBitmapImageDeviationCalculator> (new PALMBitmapImageDeviationCalculator_IntegralSquareRoot(PSFWidth, scaleFactor));
			break;
		default:
			return UNKNOWN_CCD_IMAGES_PROCESSING_METHOD;
	}
	
	// do the actual calculation
	try {
		progressReporter = boost::shared_ptr<PALMAnalysisProgressReporter> (new PALMAnalysisProgressReporter_IgorCommandLine);
		imageCalculator = boost::shared_ptr<PALMBitmapImageCalculator>(new PALMBitmapImageCalculator(deviationCalculator, emitterWeighing, progressReporter));
		boost::shared_ptr<LocalizedPositionsContainer> positions(LocalizedPositionsContainer::GetPositionsFromWave(positionsWave));
		image = imageCalculator->CalculateImage(positions, xSize, ySize, imageWidth, imageHeight);
		copy_PALMMatrix_to_IgorDPWave(image, std::string("M_PALM"));
	}
	catch (std::bad_alloc) {
		return NOMEM;
	}
	catch (CANNOT_OPEN_FILE) {
		return FILE_OPEN_ERROR;
	}
	catch (ERROR_READING_FILE_DATA e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		return FILE_READ_ERROR;
	}
	catch (END_SHOULD_BE_LARGER_THAN_START) {
		return END_SHOULD_BE_LARGER_THAN_START_DEF;
	}
	catch (std::range_error err) {
		XOPNotice(err.what());
		XOPNotice("\r");
		return INDEX_OUT_OF_RANGE;
	}
	catch (int e) {
		return e;
	}
	catch (std::runtime_error e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		return SYNERR;
	}
	catch (...) {
		return WM_UNKNOWN_ERROR;
	}
	
	return err;
}

static int ExecuteRipleyLFunctionClustering(RipleyLFunctionClusteringRuntimeParamsPtr p) {
	int err = 0;
	size_t nBins;
	double binWidth, calculationRange;
	
	// Flag parameters.
	
	if (p->RNGEFlagEncountered) {
		// Parameter: p->calculationRange
		// Parameter: p->nBins
		if ((p->calculationRange <= 0) || (p->nBins <= 0))
			return EXPECT_POS_NUM;
		
		calculationRange = p->calculationRange;
		nBins = (size_t)(p->nBins + 0.5);
		
	} else {
		return EXPECT_POS_NUM;
	}
	
	double lowerX = 0, upperX = 0, lowerY = 0, upperY = 0;
	if (p->REGNFlagEncountered) {
		// Parameter: p->lowerX
		// Parameter: p->upperX
		// Parameter: p->lowerY
		// Parameter: p->upperY
		lowerX = p->lowerX;
		upperX = p->upperX;
		lowerY = p->lowerY;
		upperY = p->upperY;
	}
	
	// Main parameters.
	
	if (p->positionsWaveEncountered) {
		// Parameter: p->positionsWave (test for NULL handle before using)
		if (p->positionsWave == NULL)
			return NOWAV;
	}
	
	
	
	try {
		boost::shared_ptr<LocalizedPositionsContainer> positions = LocalizedPositionsContainer::GetPositionsFromWave(p->positionsWave);
		boost::shared_ptr<std::vector<double> > kFunction = CalculateLFunctionClustering(positions, calculationRange, nBins, lowerX, upperX, lowerY, upperY);
		
		binWidth = calculationRange / (double)nBins;
		double dimOffset = binWidth;
		double dimDelta = binWidth;
		waveHndl outputWave = copy_vector_to_IgorDPWave(kFunction, std::string("W_LFunction"));
		err = MDSetWaveScaling(outputWave, 0, &dimDelta, &dimOffset);
	}
	catch (std::runtime_error e) {
		XOPNotice(e.what());
		XOPNotice("\r");
		return SYNERR;
	}
	catch (...) {
		XOPNotice("An unknown error occurred\r");
		return SYNERR;
	}
	
	return err;
}

static int RegisterAnalyzePALMImages(void) {
	const char* cmdTemplate;
	const char* runtimeNumVarList;
	const char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the AnalyzePALMImagesRuntimeParams structure as well.
	cmdTemplate = "AnalyzePALMImages /M=number:method /D=number:thresholding_method /Y=number:camera_type /G={number:preprocessing, number:postprocessing} /F=number:particle_finder /T=number:treshold_parameter /B=number:background /R=number:radius /W=number:initial_width /E=number:min_distance_from_edge /C=number:cutoff_radius /S=number:sigma /P=wave:positions_wave /Q /Z name:name_of_output_wave, string:experiment_file";
	runtimeNumVarList = "V_flag;";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(AnalyzePALMImagesRuntimeParams), (void*)ExecuteAnalyzePALMImages, 0);
}
static int RegisterReadCCDImages(void) {
	const char* cmdTemplate;
	const char* runtimeNumVarList;
	const char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the ReadCCDImagesRuntimeParams structure as well.
	cmdTemplate = "ReadCCDImages /Y=number:camera_type /H /Z number:start_image, number:end_image, string:experiment_file";
	runtimeNumVarList = "V_flag;V_numberOfImages;V_xSize;V_ySize;V_firstImageLoaded;V_lastImageLoaded;";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(ReadCCDImagesRuntimeParams), (void*)ExecuteReadCCDImages, kOperationIsThreadSafe);
}

static int RegisterProcessCCDImages(void) {
	const char* cmdTemplate;
	const char* runtimeNumVarList;
	const char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the ProcessCCDImagesRuntimeParams structure as well.
	cmdTemplate = "ProcessCCDImages /Y=number:camera_type /M=number:method /N=number:method_parameter /R={number:startX, number:endX, number:startY, number:endY} /OUT=number:outputType /O string:input_file, string:output_file";
	runtimeNumVarList = "V_flag";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(ProcessCCDImagesRuntimeParams), (void*)ExecuteProcessCCDImages, 0);
}

static int RegisterAnalyzeCCDImages(void) {
	char* cmdTemplate;
	char* runtimeNumVarList;
	char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the AnalyzeCCDImagesRuntimeParams structure as well.
	cmdTemplate = "AnalyzeCCDImages /Y=number:camera_type /M=number:method /R={number, number, number, number} name:output_wave, string:input_file";
	runtimeNumVarList = "";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(AnalyzeCCDImagesRuntimeParams), (void*)ExecuteAnalyzeCCDImages, 0);
}

static int RegisterTestThreshold(void) {
	char* cmdTemplate;
	char* runtimeNumVarList;
	char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the TestThresholdRuntimeParams structure as well.
	cmdTemplate = "TestThreshold /M=number:method /T=number:parameter /P=number:parameter2 /G={number:preprocessing, number:postprocessing} /F=number:particle_finder /R=number:radiusBetweenParticles /S=number:output_located_particles wave:CCD_Frame";
	runtimeNumVarList = "";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(TestThresholdRuntimeParams), (void*)ExecuteTestThreshold, 0);
}

static int RegisterConvolveImages(void) {
	char* cmdTemplate;
	char* runtimeNumVarList;
	char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the ConvolveImagesRuntimeParams structure as well.
	cmdTemplate = "ConvolveImages wave:firstImage, wave:secondImage";
	runtimeNumVarList = "";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(ConvolveImagesRuntimeParams), (void*)ExecuteConvolveImages, 0);
}

static int RegisterMakeBitmapPALMImage(void) {
	const char* cmdTemplate;
	const char* runtimeNumVarList;
	const char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the MakeBitmapPALMImageRuntimeParams structure as well.
	cmdTemplate = "MakeBitmapPALMImage /M=number:deviationMethod /S=number:scaleFactor /L=number:upperLimit /W={number:CCDXSize, number:CCDYSize, number:ImageWidth, number:ImageHeight} /WGHT=number:emitterWeighing /P=number:PSFWidth wave:positionsWave";
	runtimeNumVarList = "";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(MakeBitmapPALMImageRuntimeParams), (void*)ExecuteMakeBitmapPALMImage, 0);
}


static int RegisterRipleyLFunctionClustering(void) {
	const char* cmdTemplate;
	const char* runtimeNumVarList;
	const char* runtimeStrVarList;
	
	// NOTE: If you change this template, you must change the RipleyLFunctionClusteringRuntimeParams structure as well.
	cmdTemplate = "RipleyLFunctionClustering /RNGE={number:calculationRange, number:nBins} /REGN={number:lowerX, number:upperX, number:lowerY, number:upperY} wave:positionsWave";
	runtimeNumVarList = "";
	runtimeStrVarList = "";
	return RegisterOperation(cmdTemplate, runtimeNumVarList, runtimeStrVarList, sizeof(RipleyLFunctionClusteringRuntimeParams), (void*)ExecuteRipleyLFunctionClustering, 0);
}

/*	XOPEntry()
 
 This is the entry point from the host application to the XOP for all
 messages after the INIT message.
 */
static void XOPEntry(void) {	
	long result = 0;
	
	switch (GetXOPMessage()) {
			// We don't need to handle any messages for this XOP.
	}
	SetXOPResult(result);
}

static int RegisterOperations(void)		// Register any operations with Igor.
{
	int result;
	
	if (result = RegisterAnalyzePALMImages())
		return result;
	if (result = RegisterReadCCDImages())
		return result;
	if (result = RegisterProcessCCDImages())
		return result;
	if (result = RegisterAnalyzeCCDImages())
		return result;
	if (result = RegisterTestThreshold())
		return result;
	if (result = RegisterConvolveImages())
		return result;
	if (result = RegisterMakeBitmapPALMImage())
		return result;
	if (result = RegisterRipleyLFunctionClustering())
		return result;
	
	// There are no more operations added by this XOP.
	
	return 0;
}


/*	main(ioRecHandle)
 
 This is the initial entry point at which the host application calls XOP.
 The message sent by the host must be INIT.
 
 main does any necessary initialization and then sets the XOPEntry field of the
 ioRecHandle to the address to be called for future messages.
 */
HOST_IMPORT int main(IORecHandle ioRecHandle) {
	int result;
	
	XOPInit(ioRecHandle);							// Do standard XOP initialization.
	
	SetXOPEntry(XOPEntry);							// Set entry point for future calls.
	
	if (result = RegisterOperations()) {
		SetXOPResult(result);
	}
	else {
		SetXOPResult(0);
	}
}

class INCOMPATIBLE_WAVE_FORMAT {};


boost::shared_ptr<ImageLoader> get_image_loader_for_camera_type(size_t camera_type, std::string data_file_path) {
	
	boost::shared_ptr<ImageLoader> image_loader;
	
	switch (camera_type) {
		case 0:	// spe files
			image_loader = boost::shared_ptr<ImageLoader>(new ImageLoaderSPE(data_file_path));
			break;
		case 1:
			image_loader = boost::shared_ptr<ImageLoader>(new ImageLoaderAndor(data_file_path));
			break;
		case 2:
			image_loader = boost::shared_ptr<ImageLoader>(new ImageLoaderHamamatsu(data_file_path));
			break;
		case 3:	// 3 is reserved for TIFF files
			image_loader = boost::shared_ptr<ImageLoader>(new ImageLoaderTIFF(data_file_path));
			break;
		case 4:
			image_loader = boost::shared_ptr<ImageLoader>(new SimpleImageLoader(data_file_path));
			break;
		case 5:	// Zeiss lsm files
			image_loader = boost::shared_ptr<ImageLoader>(new ImageLoaderTIFF(data_file_path));
			break;
		case 6: // Matrix wave in Igor
			image_loader = boost::shared_ptr<ImageLoader>(new ImageLoaderIgor(data_file_path));
			break;
		default:
			throw UNSUPPORTED_CCD_FILE_TYPE;
			break;
	}
	
	return image_loader;
	
}

